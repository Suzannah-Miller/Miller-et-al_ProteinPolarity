---
title: "Classification of Polarized Proteins Using Machine Learning"
output: html_notebook
---

This notebook contains the code for the final machine learning pipeline to classify cells with or without polarized proteins. 

It takes features measured from immunofluorescence images in MATLAB and CellProfiler, combines them, scales/normalizes features, and trains a classifier on selected features.

This notebook shows the implementation for the data shown in Figures 7 & 9, where images were co-stained against the protein MCAM and F-actin and one of the three ERM (ezrin/radixin/moesin) proteins or phospho-ERM. 

Following the code for machine learning is the code used to generate figures showing the percent of polarized cells and co-polarization/colocalization analysis.

The data needed to run this analysis is included on GitHub in the folder "Input." The classifiers generated in the analyses shown in the paper are also included for full reproducibility. The supplemental data file which is exported at the end of the script is provided in the folder "Output" for comparison.

Important note: the variable "Object" in this script refers to a unique identifier assigned to every cell in the immunofluorescence data, which is the image name followed by an underscore and the number of the cell in the image based on the segmentation. This allows outputs from MATLAB, CellProfiler, and the ML classification to be compared or merged. This should not be confused with the image-analysis definition of object (a connected component in the image) which is used within the MATLAB scripts in reference to the brightest object (region) in cells. The author apologizes for what in retrospect was a poor choice in variable naming.

```{r}
R.Version()
rstudioapi::versionInfo()
```
R version 4.2.2 (2022-10-31 ucrt)
RStudio: 2022.7.2.576

Load packages:
```{r}
options(java.parameters = "-Xmx8g")
# install.packages("readxl")
# install.packages("tidyverse")
# install.packages("caret")
# install.packages("gridExtra")
# install.packages("Rdimtools")
# install.packages("gbm")
# install.packages("caretEnsemble")
# install.packages("ggbeeswarm")
# install.packages("car")
# install.packages("corrplot")
# install.packages("svglite")

## extraTrees is not maintained any longer and must be downloaded and installed from https://cran.r-project.org/src/contrib/Archive/extraTrees/. You must have RTools installed and 64-bit Java.
library(readxl)
library(tidyverse)
library(caret)
library(gridExtra)
library(corrplot)
options(rgl.useNULL=TRUE)
library(Rdimtools)
library(gbm)
library(extraTrees)
library(caretEnsemble)
library(ggbeeswarm)
library(svglite)
library(stats)
library(FSA)
library(RColorBrewer)
library(eulerr)
```

Functions:
```{r}
# This function accepts MATLAB output for 2- or 3-channel experiments, and combines them into one data.frame, appending the variable names of the channel specific measurements with the channel name provided in the input (e.g., the name of the stained protein). For a 3-channel experiment MATLAB exports 4 files. The _Cell file contains colocalization metrics and measurements shared by all channels (i.e., Area, Max Feret Diameter, etc.). The other files (_chName) contain channel specific measurements. Provide the full path for the matlab files in the function input. If there is not a 3rd channel, enter "empty" for "matlabChannel3".
importMatlabMulti <- function(matlabCell, matlabChannel1, matlabChannel2, matlabChannel3, annotation, ch1Name, ch2Name, ch3Name){
  cellMeasRaw <- read.csv(matlabCell)
  cellMeas <- cellMeasRaw %>%
    filter(!cell == "")
  cellMeas <- unique(cellMeas)
  
  ch1 <- unique(cbind(cellMeasRaw %>% dplyr::select(Area, cell), read.csv(matlabChannel1))) %>%
    filter(intensityWrampHalves != 0) %>%
    dplyr::rename(meanIntensityNotWramp = meanNotWramp,
           medianIntensityNotWramp = medianNotWramp,
           sumIntensityNotWramp = sumNotWramp,
           meanIntensityNotBright = meanNotBright,
           sumIntensityNotBright = sumNotBright,
           medianIntensityNotBright = medianNotBright) %>%
    dplyr::mutate(meanWrampOverNot = meanIntensityWramp/meanIntensityNotWramp,
           meanWrampOverNotBright = meanIntensityWramp/meanIntensityNotBright,
           meanSecondOverNotBright = meanIntensitySecond/meanIntensityNotBright,
           sumWrampOverNot = sumIntensityWramp/sumIntensityNotWramp,
           sumWrampOverNotBright = sumIntensityWramp/sumIntensityNotBright,
           sumSecondOverNotBright = sumIntensitySecond/sumIntensityNotBright,
           medianWrampOverNot = medianIntensityWramp/medianIntensityNotWramp,
           medianWrampOverNotBright = medianIntensityWramp/medianIntensityNotBright,
           medianSecondOverNotBright = medianIntensitySecond/medianIntensityNotBright,
           sumOverMedianIntensityWramp = sumIntensityWramp/medianIntensityWramp,
           relAreaWrampCell = areaWramp/Area,
           relAreaWrampBright = areaWramp/areaBrightObj,
           massDisplacement = ifelse(massDisplacement < 1, 1, massDisplacement)) %>%
    dplyr::select(-Area) %>%
    rename_with(~str_c(.,paste("_", ch1Name, sep = "")), .cols = -contains("cell", ignore.case = F))
  ch2 <- unique(cbind(read.csv(matlabChannel2), cellMeasRaw %>% dplyr::select(Area, cell))) %>%
    filter(cell %in% ch1$cell) %>%
    dplyr::rename(meanIntensityNotWramp = meanNotWramp,
           medianIntensityNotWramp = medianNotWramp,
           sumIntensityNotWramp = sumNotWramp,
           meanIntensityNotBright = meanNotBright,
           sumIntensityNotBright = sumNotBright,
           medianIntensityNotBright = medianNotBright) %>%
    dplyr::mutate(meanWrampOverNot = meanIntensityWramp/meanIntensityNotWramp,
           meanWrampOverNotBright = meanIntensityWramp/meanIntensityNotBright,
           meanSecondOverNotBright = meanIntensitySecond/meanIntensityNotBright,
           sumWrampOverNot = sumIntensityWramp/sumIntensityNotWramp,
           sumWrampOverNotBright = sumIntensityWramp/sumIntensityNotBright,
           sumSecondOverNotBright = sumIntensitySecond/sumIntensityNotBright,
           medianWrampOverNot = medianIntensityWramp/medianIntensityNotWramp,
           medianWrampOverNotBright = medianIntensityWramp/medianIntensityNotBright,
           medianSecondOverNotBright = medianIntensitySecond/medianIntensityNotBright,
           sumOverMedianIntensityWramp = sumIntensityWramp/medianIntensityWramp,
           relAreaWrampCell = areaWramp/Area,
           relAreaWrampBright = areaWramp/areaBrightObj,
           massDisplacement = ifelse(massDisplacement < 1, 1, massDisplacement)) %>%
        dplyr::select(-Area) %>%
    rename_with(~str_c(.,paste("_", ch2Name, sep = "")), .cols = -contains("cell", ignore.case = F))
  if(matlabChannel3 != "empty"){
    ch3 <- unique(cbind(cellMeasRaw %>% dplyr::select(Area, cell), read.csv(matlabChannel3))) %>%
      filter(cell %in% ch1$cell) %>%
      dplyr::rename(meanIntensityNotWramp = meanNotWramp,
             medianIntensityNotWramp = medianNotWramp,
             sumIntensityNotWramp = sumNotWramp,
             meanIntensityNotBright = meanNotBright,
             sumIntensityNotBright = sumNotBright,
             medianIntensityNotBright = medianNotBright) %>%
      dplyr::mutate(meanWrampOverNot = meanIntensityWramp/meanIntensityNotWramp,
             meanWrampOverNotBright = meanIntensityWramp/meanIntensityNotBright,
             meanSecondOverNotBright = meanIntensitySecond/meanIntensityNotBright,
             sumWrampOverNot = sumIntensityWramp/sumIntensityNotWramp,
             sumWrampOverNotBright = sumIntensityWramp/sumIntensityNotBright,
             sumSecondOverNotBright = sumIntensitySecond/sumIntensityNotBright,
             medianWrampOverNot = medianIntensityWramp/medianIntensityNotWramp,
             medianWrampOverNotBright = medianIntensityWramp/medianIntensityNotBright,
             medianSecondOverNotBright = medianIntensitySecond/medianIntensityNotBright,
             sumOverMedianIntensityWramp = sumIntensityWramp/medianIntensityWramp,
             relAreaWrampCell = areaWramp/Area,
             relAreaWrampBright = areaWramp/areaBrightObj,
             massDisplacement = ifelse(massDisplacement < 1, 1, massDisplacement)) %>%
      dplyr::select(-Area) %>%
      rename_with(~str_c(.,paste("_", ch3Name, sep = "")), .cols = -contains("cell", ignore.case = F))
  }
  
  if(matlabChannel3 != "empty"){
    matlab <- merge(cellMeas, merge(ch1, merge(ch2, ch3, by = "cell"), by = "cell"), by = "cell")
  }else{
    matlab <- merge(cellMeas, merge(ch1, ch2, by = "cell"), by = "cell")
  }
  matlab <- matlab %>%
    separate(cell, into = c("Image", "ObjectNumber"), sep = "Cell_", convert = TRUE) %>%
    dplyr::select(-Image) %>%
    dplyr::rename(Image = image) %>%
    unite(Object, c("Image","ObjectNumber"), remove = FALSE) %>%
    dplyr::select(-ObjectNumber) %>%
    arrange(Object)
    
  
  matlabAnnotated <- merge(annotation, matlab, by = "Image")
}
 
# This function reads cell-level results from CellProfiler and adds annotation from the image file
readCp <- function(cpImgPath, cpCellPath){
  cpImg <-read.csv(cpImgPath)
 
  if(any(str_detect(colnames(cpImg), "Image_FileName_ImgMcam"))){
    cpCell <- merge(read.csv(cpCellPath), dplyr::select(cpImg, ImageNumber, Image_FileName_ImgMcam), by = "ImageNumber") %>%
      unite(Object, c(Image_FileName_ImgMcam, ObjectNumber), remove = F) %>%
      arrange(Object)
  }else{
    cpCell <- merge(read.csv(cpCellPath), dplyr::select(cpImg, ImageNumber, Image_FileName_ImgMain), by = "ImageNumber") %>%
      unite(Object, c(Image_FileName_ImgMain, ObjectNumber), remove = F) %>%
      arrange(Object)
  }
}

# This function combines features measured in matlab and CellProfiler, removes redundant features, calculates CV for Intensity and IntensityEdge from CellProfiler measurements, converts Haralick features into rotation-invariant form (not angularly dependent) by taking the mean and range, and removes small round cells based on area and max Feret diameter. CellProfiler subscript (cpSubscript) and matlab channel names (chName) indicating the different channels need to match the subscripts in the input dataframes.
combineMetrics <- function(matlab, cpCell, cpSubscript1, cpSubscript2, cpSubscript3, chName1, chName2, chName3){
  metrics <- merge(matlab, cpCell, by = "Object") %>%
    dplyr::select(-AreaShape_Orientation, 
           -contains("Intensity_MedianIntensity_BgSubtracted"), 
           -contains("Intensity_IntegratedIntensity"),
           -contains("Intensity_MassDisplacement"),
           -Number_Object_Number,
           -AreaShape_MajorAxisLength, 
           -AreaShape_MinorAxisLength, 
           -AreaShape_MaxFeretDiameter,
           -AreaShape_MinFeretDiameter,
           -AreaShape_Eccentricity,
           -AreaShape_Area) %>% # Remove identical metrics from matlab and CellProfiler
    dplyr::select(-OriginalId, -contains("Image_FileName_"),
           -contains("MaxFeretCoordinates"), -contains("MinFeretCoordinates"), 
           -contains("Orientation"), -contains("MaxFeretAngle"), -contains("MinFeretAngle"), 
           -contains("wrampAngle"), -contains("secondAngle"), -contains("majAngle"), 
           -contains("Center_X"), -contains("Center_Y"), -contains("Center_Z"), -contains("Location_"), 
           -contains("BoundingBoxM"), -contains("EulerNumber")) # Remove coordinate-based metrics and nonnumeric info. 
  
  texturize <- function(cpSubscript, chName){
    metricsTexture <- metrics %>% 
      dplyr::select(Object, contains("Texture"), contains("Intensity_StdIntensityEdge"), contains("Intensity_MeanIntensity"), contains("Intensity_StdIntensity")) %>%
      dplyr::select(Object, contains(cpSubscript)) %>%
      rename_with(~gsub(cpSubscript, '', .x), .cols = everything()) %>%
      rowwise() %>%
      dplyr::mutate(Texture_AngularSecondMoment_2_Mean = mean(c(Texture_AngularSecondMoment_2_00_256, Texture_AngularSecondMoment_2_01_256, Texture_AngularSecondMoment_2_02_256, Texture_AngularSecondMoment_2_03_256)),
           Texture_AngularSecondMoment_8_Mean = mean(c(Texture_AngularSecondMoment_8_00_256, Texture_AngularSecondMoment_8_01_256, Texture_AngularSecondMoment_8_02_256, Texture_AngularSecondMoment_8_03_256)),
           Texture_Contrast_2_Mean = mean(c(Texture_Contrast_2_00_256, Texture_Contrast_2_01_256, Texture_Contrast_2_02_256, Texture_Contrast_2_03_256)),
           Texture_Contrast_8_Mean = mean(c(Texture_Contrast_8_00_256, Texture_Contrast_8_01_256, Texture_Contrast_8_02_256, Texture_Contrast_8_03_256)),
           Texture_Correlation_2_Mean = mean(c(Texture_Correlation_2_00_256, Texture_Correlation_2_01_256, Texture_Correlation_2_02_256, Texture_Correlation_2_03_256)),
           Texture_Correlation_8_Mean = mean(c(Texture_Correlation_8_00_256, Texture_Correlation_8_01_256, Texture_Correlation_8_02_256, Texture_Correlation_8_03_256)),
           Texture_DifferenceEntropy_2_Mean = mean(c(Texture_DifferenceEntropy_2_00_256, Texture_DifferenceEntropy_2_01_256, Texture_DifferenceEntropy_2_02_256, Texture_DifferenceEntropy_2_03_256)),
           Texture_DifferenceEntropy_8_Mean = mean(c(Texture_DifferenceEntropy_8_00_256, Texture_DifferenceEntropy_8_01_256, Texture_DifferenceEntropy_8_02_256, Texture_DifferenceEntropy_8_03_256)),
           Texture_DifferenceVariance_2_Mean = mean(c(Texture_DifferenceVariance_2_00_256, Texture_DifferenceVariance_2_01_256, Texture_DifferenceVariance_2_02_256, Texture_DifferenceVariance_2_03_256)),
           Texture_DifferenceVariance_8_Mean = mean(c(Texture_DifferenceVariance_8_00_256, Texture_DifferenceVariance_8_01_256, Texture_DifferenceVariance_8_02_256, Texture_DifferenceVariance_8_03_256)),
           Texture_Entropy_2_Mean = mean(c(Texture_Entropy_2_00_256, Texture_Entropy_2_01_256, Texture_Entropy_2_02_256, Texture_Entropy_2_03_256)),
           Texture_Entropy_8_Mean = mean(c(Texture_Entropy_8_00_256, Texture_Entropy_8_01_256, Texture_Entropy_8_02_256, Texture_Entropy_8_03_256)),
           Texture_InfoMeas1_2_Mean = mean(c(Texture_InfoMeas1_2_00_256, Texture_InfoMeas1_2_01_256, Texture_InfoMeas1_2_02_256, Texture_InfoMeas1_2_03_256)),
           Texture_InfoMeas1_8_Mean = mean(c(Texture_InfoMeas1_8_00_256, Texture_InfoMeas1_8_01_256, Texture_InfoMeas1_8_02_256, Texture_InfoMeas1_8_03_256)),
           Texture_InfoMeas2_2_Mean = mean(c(Texture_InfoMeas2_2_00_256, Texture_InfoMeas2_2_01_256, Texture_InfoMeas2_2_02_256, Texture_InfoMeas2_2_03_256)),
           Texture_InfoMeas2_8_Mean = mean(c(Texture_InfoMeas2_8_00_256, Texture_InfoMeas2_8_01_256, Texture_InfoMeas2_8_02_256, Texture_InfoMeas2_8_03_256)),
           Texture_InverseDifferenceMoment_2_Mean = mean(c(Texture_InverseDifferenceMoment_2_00_256, Texture_InverseDifferenceMoment_2_01_256, Texture_InverseDifferenceMoment_2_02_256, Texture_InverseDifferenceMoment_2_03_256)),
           Texture_InverseDifferenceMoment_8_Mean = mean(c(Texture_InverseDifferenceMoment_8_00_256, Texture_InverseDifferenceMoment_8_01_256, Texture_InverseDifferenceMoment_8_02_256, Texture_InverseDifferenceMoment_8_03_256)),
           Texture_SumAverage_2_Mean = mean(c(Texture_SumAverage_2_00_256, Texture_SumAverage_2_01_256, Texture_SumAverage_2_02_256, Texture_SumAverage_2_03_256)),
           Texture_SumAverage_8_Mean = mean(c(Texture_SumAverage_8_00_256, Texture_SumAverage_8_01_256, Texture_SumAverage_8_02_256, Texture_SumAverage_8_03_256)),
           Texture_SumEntropy_2_Mean = mean(c(Texture_SumEntropy_2_00_256, Texture_SumEntropy_2_01_256, Texture_SumEntropy_2_02_256, Texture_SumEntropy_2_03_256)),
           Texture_SumEntropy_8_Mean = mean(c(Texture_SumEntropy_8_00_256, Texture_SumEntropy_8_01_256, Texture_SumEntropy_8_02_256, Texture_SumEntropy_8_03_256)),
           Texture_SumVariance_2_Mean = mean(c(Texture_SumVariance_2_00_256, Texture_SumVariance_2_01_256, Texture_SumVariance_2_02_256, Texture_SumVariance_2_03_256)),
           Texture_SumVariance_8_Mean = mean(c(Texture_SumVariance_8_00_256, Texture_SumVariance_8_01_256, Texture_SumVariance_8_02_256, Texture_SumVariance_8_03_256)),
           Texture_Variance_2_Mean = mean(c(Texture_Variance_2_00_256, Texture_Variance_2_01_256, Texture_Variance_2_02_256, Texture_Variance_2_03_256)),
           Texture_Variance_8_Mean = mean(c(Texture_Variance_8_00_256, Texture_Variance_8_01_256, Texture_Variance_8_02_256, Texture_Variance_8_03_256)),
           Texture_AngularSecondMoment_2_Range = diff(range(c(Texture_AngularSecondMoment_2_00_256, Texture_AngularSecondMoment_2_01_256, Texture_AngularSecondMoment_2_02_256, Texture_AngularSecondMoment_2_03_256))),
           Texture_AngularSecondMoment_8_Range = diff(range(c(Texture_AngularSecondMoment_8_00_256, Texture_AngularSecondMoment_8_01_256, Texture_AngularSecondMoment_8_02_256, Texture_AngularSecondMoment_8_03_256))),
           Texture_Contrast_2_Range = diff(range(c(Texture_Contrast_2_00_256, Texture_Contrast_2_01_256, Texture_Contrast_2_02_256, Texture_Contrast_2_03_256))),
           Texture_Contrast_8_Range = diff(range(c(Texture_Contrast_8_00_256, Texture_Contrast_8_01_256, Texture_Contrast_8_02_256, Texture_Contrast_8_03_256))),
           Texture_Correlation_2_Range = diff(range(c(Texture_Correlation_2_00_256, Texture_Correlation_2_01_256, Texture_Correlation_2_02_256, Texture_Correlation_2_03_256))),
           Texture_Correlation_8_Range = diff(range(c(Texture_Correlation_8_00_256, Texture_Correlation_8_01_256, Texture_Correlation_8_02_256, Texture_Correlation_8_03_256))),
           Texture_DifferenceEntropy_2_Range = diff(range(c(Texture_DifferenceEntropy_2_00_256, Texture_DifferenceEntropy_2_01_256, Texture_DifferenceEntropy_2_02_256, Texture_DifferenceEntropy_2_03_256))),
           Texture_DifferenceEntropy_8_Range = diff(range(c(Texture_DifferenceEntropy_8_00_256, Texture_DifferenceEntropy_8_01_256, Texture_DifferenceEntropy_8_02_256, Texture_DifferenceEntropy_8_03_256))),
           Texture_DifferenceVariance_2_Range = diff(range(c(Texture_DifferenceVariance_2_00_256, Texture_DifferenceVariance_2_01_256, Texture_DifferenceVariance_2_02_256, Texture_DifferenceVariance_2_03_256))),
           Texture_DifferenceVariance_8_Range = diff(range(c(Texture_DifferenceVariance_8_00_256, Texture_DifferenceVariance_8_01_256, Texture_DifferenceVariance_8_02_256, Texture_DifferenceVariance_8_03_256))),
           Texture_Entropy_2_Range = diff(range(c(Texture_Entropy_2_00_256, Texture_Entropy_2_01_256, Texture_Entropy_2_02_256, Texture_Entropy_2_03_256))),
           Texture_Entropy_8_Range = diff(range(c(Texture_Entropy_8_00_256, Texture_Entropy_8_01_256, Texture_Entropy_8_02_256, Texture_Entropy_8_03_256))),
           Texture_InfoMeas1_2_Range = diff(range(c(Texture_InfoMeas1_2_00_256, Texture_InfoMeas1_2_01_256, Texture_InfoMeas1_2_02_256, Texture_InfoMeas1_2_03_256))),
           Texture_InfoMeas1_8_Range = diff(range(c(Texture_InfoMeas1_8_00_256, Texture_InfoMeas1_8_01_256, Texture_InfoMeas1_8_02_256, Texture_InfoMeas1_8_03_256))),
           Texture_InfoMeas2_2_Range = diff(range(c(Texture_InfoMeas2_2_00_256, Texture_InfoMeas2_2_01_256, Texture_InfoMeas2_2_02_256, Texture_InfoMeas2_2_03_256))),
           Texture_InfoMeas2_8_Range = diff(range(c(Texture_InfoMeas2_8_00_256, Texture_InfoMeas2_8_01_256, Texture_InfoMeas2_8_02_256, Texture_InfoMeas2_8_03_256))),
           Texture_InverseDifferenceMoment_2_Range = diff(range(c(Texture_InverseDifferenceMoment_2_00_256, Texture_InverseDifferenceMoment_2_01_256, Texture_InverseDifferenceMoment_2_02_256, Texture_InverseDifferenceMoment_2_03_256))),
           Texture_InverseDifferenceMoment_8_Range = diff(range(c(Texture_InverseDifferenceMoment_8_00_256, Texture_InverseDifferenceMoment_8_01_256, Texture_InverseDifferenceMoment_8_02_256, Texture_InverseDifferenceMoment_8_03_256))),
           Texture_SumAverage_2_Range = diff(range(c(Texture_SumAverage_2_00_256, Texture_SumAverage_2_01_256, Texture_SumAverage_2_02_256, Texture_SumAverage_2_03_256))),
           Texture_SumAverage_8_Range = diff(range(c(Texture_SumAverage_8_00_256, Texture_SumAverage_8_01_256, Texture_SumAverage_8_02_256, Texture_SumAverage_8_03_256))),
           Texture_SumEntropy_2_Range = diff(range(c(Texture_SumEntropy_2_00_256, Texture_SumEntropy_2_01_256, Texture_SumEntropy_2_02_256, Texture_SumEntropy_2_03_256))),
           Texture_SumEntropy_8_Range = diff(range(c(Texture_SumEntropy_8_00_256, Texture_SumEntropy_8_01_256, Texture_SumEntropy_8_02_256, Texture_SumEntropy_8_03_256))),
           Texture_SumVariance_2_Range = diff(range(c(Texture_SumVariance_2_00_256, Texture_SumVariance_2_01_256, Texture_SumVariance_2_02_256, Texture_SumVariance_2_03_256))),
           Texture_SumVariance_8_Range = diff(range(c(Texture_SumVariance_8_00_256, Texture_SumVariance_8_01_256, Texture_SumVariance_8_02_256, Texture_SumVariance_8_03_256))),
           Texture_Variance_2_Range = diff(range(c(Texture_Variance_2_00_256, Texture_Variance_2_01_256, Texture_Variance_2_02_256, Texture_Variance_2_03_256))),
           Texture_Variance_8_Range = diff(range(c(Texture_Variance_8_00_256, Texture_Variance_8_01_256, Texture_Variance_8_02_256, Texture_Variance_8_03_256)))) 
    metricsTexture <- metricsTexture %>%
      ungroup() %>%
      dplyr::mutate(CV_IntensityEdge = Intensity_StdIntensityEdge/Intensity_MeanIntensityEdge,
           CV_IntensityCell = Intensity_StdIntensity/Intensity_MeanIntensity) %>%
      dplyr::select(-Intensity_MeanIntensity, -Intensity_StdIntensity, -Intensity_StdIntensityEdge, -Intensity_MeanIntensityEdge) %>%
      rename_with(~str_c(., paste("_", chName, sep = "")), .cols = everything()) %>%
      dplyr::select(-contains("_256"))
  }
  metricsTexture1 <- texturize(cpSubscript1, chName1)
  metricsTexture2 <- texturize(cpSubscript2, chName2)
  if(chName3 != "empty"){metricsTexture3 <- texturize(cpSubscript3, chName3)}
  
  metrics2 <- merge(metrics %>% dplyr::select(-contains("Texture")), metricsTexture1, by.x = "Object", by.y = paste("Object_", chName1, sep = ""))
  metrics3 <- merge(metrics2, metricsTexture2, by.x = "Object", by.y = paste("Object_", chName2, sep = ""))
  if(chName3 != "empty"){
    metrics4 <- merge(metrics3, metricsTexture3, by.x = "Object", by.y = paste("Object_", chName3, sep = ""))
    metricsAll <- metrics4
  }else{
    metricsAll <- metrics3
  }
  
  metricsAll <- metricsAll %>%
      dplyr::select(-contains("Intensity_MeanIntensity_"))
  
  tooSmall <- c(metricsAll %>% filter(Area < 17000 | MaxFeretDiameter < 350) %>% dplyr::select(Object), metrics2 %>% filter(MaxFeretDiameter < 400, Area < 34000) %>% dplyr::select(Object))
  metricsClean <- metricsAll %>%
   filter(!Object %in% tooSmall[[1]], !Object %in% tooSmall[[2]])
}

# Function to rename normAreaFeatures to be specific to a certain channel's variable names:
normAreaFeaturesChannel <- function(normAreaFeatures, chName){
  chInvariantFeatures <- c("Area", "MajorAxisLength", "MinorAxisLength",  "Eccentricity", "MaxFeretDiameter", "MinFeretDiameter", "AreaShape_BoundingBoxArea", "AreaShape_ConvexArea", "AreaShape_EquivalentDiameter", "AreaShape_MaximumRadius", "AreaShape_MeanRadius", "AreaShape_MedianRadius", "AreaShape_Perimeter")

  normAreaChFeatures <- setdiff(normAreaFeatures, chInvariantFeatures) %>%
    str_c(., paste("_", chName, sep = ""))
  features <- c(chInvariantFeatures, normAreaChFeatures)
}

# Function to calculate the median of each area feature across the control condition of cells in the training experiment. The manual scoring file provided must have improperly segmented objects removed before input or those will be included in the calculation.
controlMedianAreas <- function(metricsClean, normAreaFeatures, manual){
  medianAreas <- metricsClean %>%
    filter(Object %in% manual$Object) %>% # Remove incorrectly segmented (not a single cell) objects
    dplyr::select(all_of(normAreaFeatures), "Normalization") %>%
    filter(Normalization == "Control") %>% # From annotation file
    group_by(Normalization) %>%
    summarize_all(median, na.rm = T) %>%
    ungroup() %>%
    dplyr::select(-Normalization)
} 

# This function scales area-based features by dividing by the median value of cells in the training experiment (control-condition only). It also normalizes intensity values (to account for variability between conditions and experiments collected on different days) by providing values in relative terms (dividing measurements by the mean or integrated intensity of the cell). Features that are already expressed as a proportion or a [0 1] scale are not changed (e.g., profile measurement, relative area, wrampHalves, brightPix, etc.).
scaleAreaIntensity <- function(metrics, normAreaFeatures, controlMedian, colocFeatures, chName, cpSubscript){
  areaMetrics <- dplyr::select(metrics, all_of(normAreaFeatures))
  scaleArea <- as.data.frame(mapply('/', areaMetrics, controlMedian)) #%>%
    #dplyr::mutate_all(log)
  
  annotFeatures <- c("Object", "Image", "Experiment", "Replicate", "Coverslip", "Condition", "mainCondition", "mainReplicate", "experimentGroup", "Normalization")
  normNonArea <- metrics %>%
    dplyr::select(-all_of(colocFeatures)) %>%
    dplyr::select(-all_of(normAreaFeatures)) %>%
    dplyr::select(any_of(annotFeatures), contains(paste("_", chName, sep = "")), contains(cpSubscript)) %>%
    rename_with(~gsub(cpSubscript, '', .x), .cols = contains(cpSubscript)) %>%
    rename_with(~gsub(paste("_", chName, sep = ""), '', .x), .cols = contains(paste("_", chName, sep = ""))) %>%
    dplyr::select(-largeObj, -brightMeanObj, -brightSumObj) %>%
    dplyr::mutate(angleWramp2Major = angleWramp2Major/90,
           angleSecond2Major = angleSecond2Major/90,
           angleWramp2Second = angleWramp2Second/180,
           intensityWrampHalves = log(intensityWrampHalves),
           intensityMajorHalves = log(intensityMajorHalves),
           intensitySecondHalves = log(intensitySecondHalves),
           medianObjectMeanIntensity = medianObjectMeanIntensity/meanIntensityCell,
           medianObjectSumIntensity = medianObjectSumIntensity/sumIntensityCell,   
           meanIntensityWramp = meanIntensityWramp/meanIntensityCell,
           medianIntensityWramp = medianIntensityWramp/medianIntensityCell,
           meanIntensityBrightObj = meanIntensityBrightObj/meanIntensityCell,
           sumIntensityBrightObj = sumIntensityBrightObj/sumIntensityCell,
           sumIntensityWramp = sumIntensityWramp/sumIntensityCell,
           sumIntensityNotWramp = sumIntensityNotWramp/sumIntensityCell, 
           sumIntensityNotBright = sumIntensityNotBright/sumIntensityCell, 
           sumIntensitySecond = sumIntensitySecond/sumIntensityCell,
           meanIntensityNotWramp = meanIntensityNotWramp/meanIntensityCell,
           medianIntensityNotWramp = medianIntensityNotWramp/medianIntensityCell,
           meanIntensityNotBright = meanIntensityNotBright/meanIntensityCell,
           medianIntensityNotBright = medianIntensityNotBright/medianIntensityCell,
           meanIntensitySecond = meanIntensitySecond/meanIntensityCell,
           medianIntensitySecond = medianIntensitySecond/medianIntensityCell) %>%
    dplyr::mutate(Intensity_LowerQuartileIntensity = Intensity_LowerQuartileIntensity/meanIntensityCell, 
                  Intensity_MADIntensity = Intensity_MADIntensity/meanIntensityCell,
                  Intensity_MaxIntensityEdge = Intensity_MaxIntensityEdge/meanIntensityCell,
                  Intensity_MaxIntensity = Intensity_MaxIntensity/meanIntensityCell,
                  Intensity_MeanIntensityEdge = Intensity_MeanIntensityEdge/meanIntensityCell,
                  Intensity_MinIntensityEdge = Intensity_MinIntensityEdge/meanIntensityCell,
                  Intensity_MinIntensity = Intensity_MinIntensity/meanIntensityCell,
                  Intensity_UpperQuartileIntensity = Intensity_UpperQuartileIntensity/meanIntensityCell) %>%
    dplyr::select(-meanIntensityCell, -medianIntensityCell, -sumIntensityCell, -Intensity_StdIntensityEdge, -Intensity_StdIntensity, 
           -contains("MeanFrac_")) %>%
    rename_with(~str_c(., paste("_", chName, sep = "")), .cols = -contains(annotFeatures))
  # Note that the chName is not appended to the "medianObjectMeanIntensity" and "medianObjectSumIntensity" features, because "Object" is contained in the annotFeatures variable. 
  normMetrics <- cbind(normNonArea, scaleArea)
}

# Confusion matrix of ML classification (prediction) vs. manual scoring (reference)
# Supply fit from caret to function
analyzeResults <- function(dataset, fit, score, conditionName){
  dataset <- dplyr::select(dataset, -Normalization) %>%
    rename(refScore = score,
           useCondition = conditionName)
  Prediction <- predict(fit, dataset)
  Reference <- dataset$refScore
  ConditionGroup <- dataset$useCondition
  Confidence <- dplyr::select(dataset, contains("Confidence"))
  confusData <- data.frame(as.character(Prediction), as.character(Reference), ConditionGroup, Confidence) %>%
    dplyr::mutate(Prediction = factor(Prediction, levels = c("OneEnd", "BothEnds", "None")),
           Reference = factor(Reference, levels = c("OneEnd", "BothEnds", "None")))

  conditions <- unique(confusData$ConditionGroup)
  for(val in 1:length(conditions)){
    print(conditions[val])
    print(caret::confusionMatrix(confusData$Prediction[confusData$ConditionGroup == conditions[val]],
                      confusData$Reference[confusData$ConditionGroup == conditions[val]]))
    print("High Confidence")
    print(caret::confusionMatrix(confusData$Prediction[confusData$ConditionGroup == conditions[val] & confusData$Confidence !=2],
                      confusData$Reference[confusData$ConditionGroup == conditions[val] & confusData$Confidence != 2]))
  }
  
  ggplot(confusData, aes(x = ConditionGroup)) + geom_bar(aes(fill = Prediction), position = position_fill(reverse = T))
}

# Alternate function for generating confusion matrix. Add ML classification as a variable to the dataset before inputting to function. Provide names of both variables to compare (e.g., ML classification and manual score)
analyzeResults2 <- function(dataset, className, score, conditionName){
  dataset <- dplyr::select(dataset, -Normalization) %>%
    dplyr::rename(Prediction = className,
                  refScore = score,
                  useCondition = conditionName)
  Prediction <- dataset$Prediction
  Reference <- dataset$refScore
  ConditionGroup <- dataset$useCondition
  Confidence <- dplyr::select(dataset, contains("Confidence"))
  
  confusData <- data.frame(as.character(Prediction), as.character(Reference), ConditionGroup, Confidence) %>%
    dplyr::mutate(Prediction = factor(Prediction, levels = c("OneEnd", "BothEnds", "None")),
           Reference = factor(Reference, levels = c("OneEnd", "BothEnds", "None")))
  
  conditions <- unique(confusData$ConditionGroup)
  for(val in 1:length(conditions)){
    print(conditions[val])
    print(caret::confusionMatrix(confusData$Prediction[confusData$ConditionGroup == conditions[val]],
                      confusData$Reference[confusData$ConditionGroup == conditions[val]]))
    print("High Confidence")
    print(caret::confusionMatrix(confusData$Prediction[confusData$ConditionGroup == conditions[val] & confusData$Confidence !=2],
                      confusData$Reference[confusData$ConditionGroup == conditions[val] & confusData$Confidence != 2]))
  }
  
  ggplot(confusData, aes(x = ConditionGroup)) + geom_bar(aes(fill = Prediction), position = position_fill(reverse = T))
}

# Function for iterative training by upsampling "hard-to-classify" cells into subsequent training sets
# Updated version - takes 85% of previous training set for new training set instead of 70%
upSample85 <- function(labeledData, classVariableName, startTrainObjects, trainControl, trainFeatures, timesUpsampled){
  labeledData <- labeledData %>%
    rename(class = classVariableName)
  
  gridGbm <- expand.grid(n.trees = c(50, 100, 150, 300, 600),
                            interaction.depth = c(1, 2),
                            shrinkage = c(0.025, 0.1),
                            n.minobsinnode = 10)
  
  gridExtraTrees <- expand.grid(mtry = c(10, 25, 40),
                                numRandomCuts = 3)
  
  trainObjects <- list(Zero = startTrainObjects)
  trainNum <- c("Zero", "One", "Two")
  
  timesUpsampled <- timesUpsampled + 1
  
  for(val in 1:timesUpsampled){
    set.seed(123)
    fitGbm <- caret::train(labeledData %>% filter(Object %in% trainObjects[[trainNum[val]]]) %>%
                             dplyr::select(all_of(trainFeatures)),
                            labeledData$class[labeledData$Object %in% trainObjects[[trainNum[val]]]],
                            method = "gbm",
                            preProcess = NULL,
                            tuneGrid = gridGbm)
    
    set.seed(123)
    fitExtraTrees <- caret::train(labeledData %>% filter(Object %in% trainObjects[[trainNum[val]]]) %>%
                                    dplyr::select(all_of(trainFeatures)),
                                  labeledData$class[labeledData$Object %in% trainObjects[[trainNum[val]]]],
                                  method = "extraTrees",
                                  preProcess = NULL,
                                  tuneGrid = gridExtraTrees)
    
    labeledData$predictGbm <- predict(fitGbm, labeledData %>% dplyr::select(all_of(trainFeatures)))
    labeledData$predictExtra <- predict(fitExtraTrees, labeledData %>% dplyr::select(all_of(trainFeatures)))
    
    falses <- labeledData %>%
      filter(predictGbm != class | predictExtra != class) %>% 
      filter(!Object %in% trainObjects[[trainNum[val]]]) %>% 
      dplyr::select(Object)
    
    set.seed(123)
    newTrainObjects <- c(sample(trainObjects[[trainNum[val]]], 
                                round(.85*length(trainObjects[[trainNum[val]]])), replace = FALSE),
                         sample(falses$Object, round(0.7*nrow(falses)), replace = T))
    
    if(val == 1){
      trainObjects <- list(Zero = trainObjects[[trainNum[val]]], One = newTrainObjects)
    }else if(val == 2){
    trainObjects <-  append(trainObjects, list(Two = newTrainObjects))
    }
    
    if(val == 1){
      models <- list(gbmZero = fitGbm, 
                     extraTreesZero = fitExtraTrees)
    }else if(val == 2){
      models <- append(models, 
                            list(gbmOne = fitGbm, 
                            extraTreesOne = fitExtraTrees))
    }else{
      models <- append(models, 
                            list(gbmTwo = fitGbm, 
                            extraTreesTwo = fitExtraTrees))
    }
  }
  list(trainingSets = trainObjects, fittedModels = models)
}

# Wrapper function to fit two models and generate a combined classification where both classifiers must agree on one-ended WRAMP structures (reduces false positives at the cost of sensitivity). Classes are added to the metricsClean dataframe.
classifyCleanMetricsCombinedModels <- function(metricsCleaned, metricsScaled, fit1, fit2, columnName){
  metricsCleaned <- arrange(metricsCleaned, Object)
  metricsScaled <- arrange(metricsScaled, Object)
  metricsCleaned$prediction1 <- predict(fit1, metricsScaled)
  metricsCleaned$prediction2 <- predict(fit2, metricsScaled)
  metricsCleaned <- metricsCleaned %>%
    dplyr::mutate(prediction1 = as.character(prediction1), prediction2 = as.character(prediction2)) %>%
    dplyr::mutate(combo = ifelse((prediction1 == "OneEnd" & prediction2 != "OneEnd"), "None", prediction1)) %>%
    dplyr::mutate_at(c("prediction1", "prediction2", "combo"), function(x){factor(x, levels = c("OneEnd", "BothEnds", "None"))}) %>%
    dplyr::select(-prediction1, -prediction2) %>%
    dplyr::rename_with(~ gsub("combo", columnName, .x), .cols = "combo")
}

# Wrapper to apply a single classifer to the data
classifyCleanMetricsOneModel <- function(metricsCleaned, metricsScaled, fit1, columnName){
  metricsCleaned <- arrange(metricsCleaned, Object)
  metricsScaled <- arrange(metricsScaled, Object)
  metricsCleaned$prediction1 <- predict(fit1, metricsScaled)
  metricsCleaned <- metricsCleaned %>%
  dplyr::rename_with(~ gsub("prediction1", columnName, .x), .cols = "prediction1")
}

checkTypos <- function(rawScoring){
  print(unique(rawScoring$Segmentation))
  print(unique(rawScoring$WrongObject))
  print(unique(rawScoring$ManualScoreMcam))
  print(unique(rawScoring$ConfidenceMcam))
  print(unique(rawScoring$ManualScoreFactin))
  print(unique(rawScoring$ConfidenceFactin))
  print(unique(rawScoring$ManualScoreOther))
  print(unique(rawScoring$ConfidenceOther))
  print(unique(rawScoring$SameSideFactin))
  print(unique(rawScoring$SameSideOther))
}

```

Path for base directory:
```{r}
dirPath <- "C:/Users/sumi6491/Documents/CrisprClones/Analysis20221211/CrisprAnalysisInR/"
```

Annotation file, where user defines conditions and replicates for each image.
```{r}
annotationCrispr <- read.csv(paste(dirPath, "Input/AnnotationCrisprIF.csv", sep = ""))

annotationCrispr %>% group_by(Experiment, Condition, Replicate, Coverslip) %>% count() %>% ungroup()
unique(annotationCrispr$Condition)

head(annotationCrispr)
```

Computational data:
```{r}
# MATLAB output
# MATLAB was stopped and run in two parts because of the large number of images and low-level graphics errors.
matlabPt1 <- importMatlabMulti(paste(dirPath, "Input/FeatureData/80thPctlNoCloseStats_Cell_20221211.csv", sep = ""), paste(dirPath, "Input/FeatureData/80thPctlNoCloseStats_MCAM_20221211.csv", sep = ""), paste(dirPath, "Input/FeatureData/80thPctlNoCloseStats_Other_20221211.csv", sep = ""), paste(dirPath, "Input/FeatureData/80thPctlNoCloseStats_Factin_20221211.csv", sep = ""), annotationCrispr, "MCAM", "Other", "Third") %>%
  filter(!str_detect(Image, "20220926")) # Remove images which overlap with part 2

matlabPt2 <- importMatlabMulti(paste(dirPath, "Input/FeatureData/80thPctlNoCloseStats_Cell_20221212.csv", sep = ""), paste(dirPath, "Input/FeatureData/80thPctlNoCloseStats_MCAM_20221212.csv", sep = ""), paste(dirPath, "Input/FeatureData/80thPctlNoCloseStats_Other_20221212.csv", sep = ""), paste(dirPath, "Input/FeatureData/80thPctlNoCloseStats_Factin_20221212.csv", sep = ""), annotationCrispr, "MCAM", "Other", "Third")

matlabCrispr <- rbind(matlabPt1, matlabPt2) %>% arrange(Object)

# Check for duplicate objects
sum(duplicated(matlabCrispr))
nrow(matlabCrispr) == length(unique(matlabCrispr$Object))

# CellProfiler output
cpCellCrispr <- readCp(paste(dirPath, "Input/FeatureData/20221214_CellProfilerMetrics-CrisprERM_Image.csv", sep = ""),
                 paste(dirPath, "Input/FeatureData/20221214_CellProfilerMetrics-CrisprERM_Cell.csv", sep = "")) %>%
  dplyr::mutate(Object = str_replace(Object, "_main.tif", ".nd2"))

```

Check that objects were named identically for MATLAB and CellProfiler outputs. If this is true, setdiff should be 0 (empty). Note that the CellProfiler output may be a few rows longer than the imported MATLAB data because rarely a segmented cell can't be processed in MATLAB and is skipped.
```{r}
setdiff(cpCellCrispr$Object, matlabCrispr$Object)
```

Clean and combine MATLAB and CellProfiler metrics:
```{r}
metricsCleanCrispr <- combineMetrics(matlabCrispr, cpCellCrispr, "_BgSubtractedMain", "_BgSubtractedOther", "_BgSubtractedThird", "MCAM", "Other", "Third")

unique(metricsCleanCrispr %>% dplyr::select(Experiment, Condition, Replicate))
str(metricsCleanCrispr)

nrow(metricsCleanCrispr) == nrow(metricsCleanCrispr %>% filter(str_detect(Image, "MCAM488"))) # All images have MCAM-AF488 staining (SC-18837 mouse mAb)
```
Prepare for ML classification of MCAM staining
```{r}
# Copied from MachineLearningDevelopment folder 
normAreaFeaturesGeneric <- read.csv(paste(dirPath, "Input/normAreaFeatures.csv", sep = ""))[,"x"]

normAreaFeatures.MCAM <- normAreaFeaturesChannel(normAreaFeaturesGeneric, "MCAM")
normAreaFeatures.Other <- normAreaFeaturesChannel(normAreaFeaturesGeneric, "Other")

medianAreas.MCAM <- read.csv(paste(dirPath, "Input/medianAreasMcamControl.csv", sep = "")) %>% dplyr::select(-X)

colocFeatures <- read.csv(paste(dirPath, "Input/colocFeatures.csv", sep = ""))[,"x"]

# List of features used for training ML classifier
reducedFeatures.MCAM <- read.csv(paste(dirPath, "Input/SelectedFeaturesMcam.csv", sep = ""))[,"x"]
# Further reduced set of features where Haralick Texture features and CV_IntensityEdge feature are removed
reducedFeatures.MCAM2 <- setdiff(reducedFeatures.MCAM, colnames(metricsCleanCrispr %>% dplyr::select("CV_IntensityEdge_MCAM", contains("Texture"))))

# Scale or convert features for a single channel to scale-invariant forms
metricsScaled.MCAM <- scaleAreaIntensity(metricsCleanCrispr, normAreaFeatures.MCAM, medianAreas.MCAM, colocFeatures, "MCAM", "_BgSubtractedMain")
head(metricsScaled.MCAM)
```

A subset of data was processed and classified during a preliminary analysis of images co-stained for MCAM and MSN (not shown). More manual annotation was done here to create a larger/training and test set and to create labeled data for classification of the other ERM proteins.

Apply classifier from preliminary analysis to select additional data for manual classification that is relatively balanced between classes and experiments:
```{r}
prevModel <- readRDS(paste(dirPath, "Input/modelList20221205_85up_Control_NoTexture", sep = ""))

metricsClean.Classified.MCAM.prelim <- classifyCleanMetricsCombinedModels(metricsCleanCrispr, metricsScaled.MCAM, prevModel[["fittedModels"]][["gbmTwo"]], prevModel[["fittedModels"]][["extraTreesTwo"]], "prelimClassMcam")

remove(prevModel)
```

Shuffle and blind cells for manual classification (this chunk copies blinded images of individual cells to a new folder):
```{r}
# Cells already scored during preliminary analysis
manualTrain1 <- read.csv(paste(dirPath, "Input/manualScoringTrainingSet1_20221205.csv", sep = "")) %>% 
  dplyr::mutate(SameSideOther = as.character(SameSideOther))

# trainingObjects2 <- rbind(metricsClean.Classified.MCAM.prelim %>%
#                            filter(!Object %in% manualTrain1$Object) %>%
#                            filter(!str_detect(Condition, "MSN")) %>% # Don't score any more from this staining set
#                            filter(str_detect(Condition, "Naive")) %>%
#                            group_by(prelimClassMcam, Experiment, Condition) %>% # Get about the same number of cells per experiment and staining condition
#                            filter(prelimClassMcam != "BothEnds") %>%
#                            slice_sample(n = 40, replace = F) %>%
#                             ungroup(),
#                          metricsClean.Classified.MCAM.prelim %>% # Take fewer of the CRISPR clone cells
#                            filter(!Object %in% manualTrain1$Object) %>%
#                            filter(!str_detect(Condition, "MSN")) %>% # Don't score any more from this staining set
#                            filter(!str_detect(Condition, "Naive")) %>%
#                            group_by(prelimClassMcam, Experiment, Condition) %>% # Get about the same number of cells per experiment and staining condition
#                            filter(prelimClassMcam != "BothEnds") %>%
#                            slice_sample(n = 25, replace = F) %>%
#                             ungroup(),
#                          metricsClean.Classified.MCAM.prelim %>%
#                           filter(prelimClassMcam == "BothEnds")) %>% # Take all of the "BothEnds" classes as this is a small proportion of cells
#                           dplyr::select(prelimClassMcam, Object)
#                          
# 
# 
# write_csv(trainingObjects2, paste(dirPath, "Output/trainingSet2_20221215.csv", sep = ""))
# trainingObjects2 <- read.csv(paste(dirPath, "Output/trainingSet2_20221215.csv", sep = ""))
# 
# # Shuffle cells
# nCells <- length(trainingObjects2$Object)
# set.seed(123)
# fileNameV1 <- paste(gsub(".nd2", "_Img_Cell", trainingObjects2$Object)[sample(nCells, nCells, replace = F)], "_80thPctlNoClose.png", sep = "")
# fileNameV2 <- gsub("_80thPctlNoClose.png", "_Img_Cell_80thPctlNoClose.png", gsub("_Img_Cell", "", fileNameV1))
# 
# renameMatrix <- data.frame(newNum = 1:(nCells), imgNameV1 = fileNameV1, imgNameV2 = fileNameV2) %>%
#   dplyr::mutate(newNameImg = paste("80thPctlNoClose_", as.character(newNum), "_Img.png", sep = ""),
#          newNameFig = paste("80thPctlNoClose_", as.character(newNum), "_Fig.png", sep = ""),
#          figNameV1 = paste("Bg_", str_replace(imgNameV1, "Img", "Figure"), sep = ""),
#          figNameV2 = str_replace(imgNameV2, "Img", "Figure")) %>%
#    dplyr::mutate(pathNameImgV1 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/", imgNameV1, sep = ""),
#           pathNameImgV2 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/", imgNameV2, sep = ""),
#           pathNameFigV1 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/", figNameV1, sep = ""),
#           pathNameFigV2 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/", figNameV2, sep = "")) %>%
#   dplyr::mutate(toPathNameImgV1 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/TrainingSet2/", imgNameV1, sep = ""),
#           toPathNameImgV2 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/TrainingSet2/", imgNameV2, sep = ""),
#           toPathNameFigV1 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/TrainingSet2/", figNameV1, sep = ""),
#           toPathNameFigV2 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/TrainingSet2/", figNameV2, sep = ""))
# 
# file.copy(from = renameMatrix$pathNameImgV1, to = renameMatrix$toPathNameImgV1)
# file.copy(from = renameMatrix$pathNameImgV2, to = renameMatrix$toPathNameImgV2)
# file.copy(from = renameMatrix$pathNameFigV1, to = renameMatrix$toPathNameFigV1)
# file.copy(from = renameMatrix$pathNameFigV2, to = renameMatrix$toPathNameFigV2)
# 
# setwd(paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/TrainingSet2/", sep = ""))
# write.csv(renameMatrix, "Blinding_TrainingSet2_20221215.csv")
# file.rename(renameMatrix$imgNameV1, renameMatrix$newNameImg)
# file.rename(renameMatrix$imgNameV2, renameMatrix$newNameImg)
# file.rename(renameMatrix$figNameV1, renameMatrix$newNameFig)
# file.rename(renameMatrix$figNameV2, renameMatrix$newNameFig)
```

New manual scoring. Note: there were some cells scored twice because I forgot to filter out previously scored cells for the BothEnds class. There were also some additional cells with MSN staining that were scored in the second training set which had a preliminary BothEnds assignment and were not filtered out by the above code.
```{r}
manualTrain2 <-read.csv(paste(dirPath, "Input/manualScoringTrainingSet2_20221215.csv", sep = ""))

# manualTrain <- rbind(manualTrain1, manualTrain2)
# # Check for duplicate objects
# sum(duplicated(manualTrain$Object))
# filter(metricsClean.Classified.MCAM.prelim, Object %in% manualTrain$Object[duplicated(manualTrain$Object)]) %>% select(prelimClassMcam)

# Combine manual scoring from preliminary and new manual scoring:
manualTrain <- rbind(manualTrain1, manualTrain2 %>% filter(!Object %in% manualTrain1$Object))
sum(duplicated(manualTrain$Object))

manualTrain %>% count(Experiment)
manualTrain %>% group_by(Experiment) %>% count(Condition) %>% ungroup()
manualTrain %>% group_by(Experiment) %>% count(ManualScoreMcam) %>% ungroup()
manualTrain %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                mainRep = str_remove(Replicate, "_Stain.*")) %>% group_by(mainCondition, mainRep) %>% count() %>% ungroup()
```

Train a machine learning classifier for polarized MCAM:
```{r}
metricsScaled.MCAM.labeled <- metricsScaled.MCAM %>%
  merge(manualTrain %>% dplyr::select(ManualScoreMcam, ConfidenceMcam, Object, Segmentation), by = "Object") %>%
  filter(is.na(Segmentation)) %>% # Remove cells with bad segmentation cells
  dplyr::select(-Segmentation)
  
# Balanced labeled data for training/testing:
# For classifier for all cell lines, balance the number of cells per cell line
manualTrain.All.Balanced <- rbind(manualTrain %>%
      dplyr::mutate(mainRep = str_remove(Replicate, "_Stain.*")) %>%
      filter(Experiment!= "20220907_Pilot") %>%
      group_by(mainRep) %>%
      slice_sample(n = 130, replace = F) %>%
      ungroup() %>%
      dplyr::select(-mainRep),
  manualTrain %>% filter(Experiment == "20220907_Pilot")) %>%
  filter(is.na(Segmentation))
manualTrain.All.Balanced %>% count(Experiment)
# write_csv(manualTrain.All.Balanced, paste(dirPath, "Output/BalancedManualScoring_20221218.csv", sep=""))

manualTrain.All.Balanced <- read.csv(paste(dirPath, "Input/BalancedManualScoring_20221218.csv", sep=""))

# Create training set for input into the upSample85 function
set.seed(123)
trainingSetMcamObjects.All <- manualTrain.All.Balanced$Object[createDataPartition(manualTrain.All.Balanced$ManualScoreMcam, p = 0.7, list = F, times = 1)]
metricsScaled.MCAM.labeled %>% filter(Object %in% trainingSetMcamObjects.All) %>% count(Condition)

# Control parameters for training with caret package:
myControlUpsample <- trainControl(method = "repeatedcv",
                                  number = 10, # number of k-folds
                                  repeats = 3,
                                  savePredictions = "final",
                                  classProbs = T)
# Model with 49 selected features
mcamModel1_85.All <- upSample85(metricsScaled.MCAM.labeled, "ManualScoreMcam", trainingSetMcamObjects.All, myControlUpsample, reducedFeatures.MCAM, timesUpsampled = 2)
# prepareForSave(mcamModel1_85.All[["fittedModels"]][["extraTreesZero"]]$finalModel)
# prepareForSave(mcamModel1_85.All[["fittedModels"]][["extraTreesOne"]]$finalModel)
# prepareForSave(mcamModel1_85.All[["fittedModels"]][["extraTreesTwo"]]$finalModel)
# saveRDS(mcamModel1_85.All, paste(dirPath, "Output/ClassifiersForMcam/modelList20221218_85up_All_MCAM", sep = ""))

# Model with 36 selected features (remove Haralick Texture features and CV_IntensityEdge)
mcamModel2_85.All <- upSample85(metricsScaled.MCAM.labeled, "ManualScoreMcam", trainingSetMcamObjects.All, myControlUpsample, reducedFeatures.MCAM2, timesUpsampled = 2)
# prepareForSave(mcamModel2_85.All[["fittedModels"]][["extraTreesZero"]]$finalModel)
# prepareForSave(mcamModel2_85.All[["fittedModels"]][["extraTreesOne"]]$finalModel)
# prepareForSave(mcamModel2_85.All[["fittedModels"]][["extraTreesTwo"]]$finalModel)
# saveRDS(mcamModel2_85.All, paste(dirPath, "Output/ClassifiersForMcam/modelList20221218_85up_All_NoTexture_MCAM", sep = ""))
```

Load classifiers trained in the previous chunk:
```{r}
mcamModel1_85.All <- readRDS(paste(dirPath, "Input/Classifiers/modelList20221218_85up_All_MCAM", sep = ""))
mcamModel2_85.All <- readRDS(paste(dirPath, "Input/Classifiers/modelList20221218_85up_All_NoTexture_MCAM", sep = ""))
```

Evaluate accuracy of different combinations of classifiers:
```{r}
# Classifies data using a combination of two classifiers such that both classifiers are required to classify a cell as "One End"
# Using the gbm and extraTrees models from two rounds of upsampling, with or without selection of Haralick Texture features
metricsClean.Classified.MCAM.Two.All <- classifyCleanMetricsCombinedModels(classifyCleanMetricsCombinedModels(metricsCleanCrispr, 
                                                                               metricsScaled.MCAM, 
                                                                               mcamModel2_85.All[["fittedModels"]][["gbmTwo"]],
                                                                               mcamModel2_85.All[["fittedModels"]][["extraTreesTwo"]],
                                                                               "comboGbmExtraTwo_MCAM2"),
                                                                           metricsScaled.MCAM, 
                                                                           mcamModel1_85.All[["fittedModels"]][["gbmTwo"]],
                                                                           mcamModel1_85.All[["fittedModels"]][["extraTreesTwo"]],
                                                                           "comboGbmExtraTwo_MCAM1") %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                mainRep = str_remove(Replicate, "_Stain.*")) %>%
  dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4")))

# Using the gbm and extraTrees models from one round of upsampling and without Haralick Texture features.
metricsClean.Classified.MCAM.One <- classifyCleanMetricsCombinedModels(metricsCleanCrispr,
                                                                           metricsScaled.MCAM, 
                                                                           mcamModel2_85.All[["fittedModels"]][["gbmOne"]],
                                                                           mcamModel2_85.All[["fittedModels"]][["extraTreesOne"]],
                                                                           "comboGbmExtraOne_MCAM2A") %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                mainRep = str_remove(Replicate, "_Stain.*")) %>%
  dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4")))


# Including texture features gives lower sensitivity
analyzeResults2(metricsClean.Classified.MCAM.Two.All %>%
                  merge(manualTrain %>% filter(is.na(Segmentation)) %>%
                          dplyr::select(ManualScoreMcam, ConfidenceMcam, Object), by = "Object") %>%
                  filter(!Object %in% mcamModel1_85.All[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_MCAM1",
               "ManualScoreMcam", "mainCondition") # Low sensitivity

# Best classifier (two rounds of upsampling, 36 features)
analyzeResults2(metricsClean.Classified.MCAM.Two.All %>% 
                  merge(manualTrain %>% filter(is.na(Segmentation)) %>% 
                          dplyr::select(ManualScoreMcam, ConfidenceMcam, Object), by = "Object") %>%
                  filter(!Object %in% mcamModel2_85.All[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_MCAM2",
               "ManualScoreMcam", "mainCondition")

analyzeResults2(metricsClean.Classified.MCAM.Two.All %>% 
                  merge(manualTrain %>% filter(is.na(Segmentation)) %>% 
                          dplyr::select(ManualScoreMcam, ConfidenceMcam, Object), by = "Object") %>%
                  filter(!Object %in% mcamModel2_85.All[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_MCAM2",
               "ManualScoreMcam", "Experiment")

analyzeResults2(metricsClean.Classified.MCAM.Two.All %>% 
                  merge(manualTrain %>% filter(is.na(Segmentation)) %>% 
                          dplyr::select(ManualScoreMcam, ConfidenceMcam, Object), by = "Object") %>%
                  filter(!Object %in% mcamModel2_85.All[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_MCAM2",
               "ManualScoreMcam", "mainRep")

# One round of upsampling is less accurate than two
analyzeResults2(metricsClean.Classified.MCAM.One %>%
                  merge(manualTrain %>% filter(is.na(Segmentation)) %>%
                          dplyr::select(ManualScoreMcam, ConfidenceMcam, Object), by = "Object") %>%
                  filter(!Object %in% mcamModel2_85.All[["trainingSets"]][["One"]]),
               "comboGbmExtraOne_MCAM2A",
               "ManualScoreMcam", "mainCondition")
```
The second round of upsampling with the further reduced set of features is best. 


Training classifiers for the "other" proteins (stained in the "other" image channel).

MSN:
```{r}
reducedFeatures.Other <- str_replace(reducedFeatures.MCAM, "_MCAM", "_Other")
reducedFeatures.Other2 <- str_replace(reducedFeatures.MCAM2, "_MCAM", "_Other")

# Calculate median values for scaling area/distance features
medianAreas.MSN <- controlMedianAreas(metricsCleanCrispr %>% filter(str_detect(Condition, "MSN")),
                                      normAreaFeatures.Other,
                                      manualTrain1 %>% filter(str_detect(Condition, "MSN"), is.na(Segmentation))) # Note: used manualTrain1 instead of  manualTrain (some additional MSN cells in manualTrain from BothEnds class)


metricsScaled.MSN <- scaleAreaIntensity(metricsCleanCrispr %>%
  filter(str_detect(Condition, "MSN")), normAreaFeatures.Other, medianAreas.MSN, colocFeatures, "Other", "_BgSubtractedOther")

metricsScaled.MSN.labeled <- metricsScaled.MSN %>%
  merge(manualTrain %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object, Segmentation), by = "Object") %>%
  filter(str_detect(Condition, "MSN")) %>%
  filter(is.na(Segmentation)) %>%
  dplyr::select(-Segmentation)

# Check removal of images without MSN staining
identical(metricsCleanCrispr %>% filter(str_detect(Image, "MSN")) %>% dplyr::select(Object),
  metricsScaled.MSN %>% dplyr::select(Object))

# Objects for starting training set:
# Compared starting with the balanced set (# of cells per cell line) of labeled data vs. using all labeled data
manualTrain.All.Balanced.MSN <- manualTrain.All.Balanced %>% filter(str_detect(Condition, "MSN"))
manualTrain.All.MSN <- manualTrain %>% filter(str_detect(Condition, "MSN")) %>% filter(is.na(Segmentation)) # Try training with more cells but unbalanced conditions

set.seed(123)
trainingSetMsnObjects.All <- manualTrain.All.MSN$Object[createDataPartition(manualTrain.All.MSN$ManualScoreOther, p = 0.7, list = F, times = 1)]
set.seed(123)
trainingSetMsnObjects.All.Balanced <- manualTrain.All.Balanced.MSN$Object[createDataPartition(manualTrain.All.Balanced.MSN$ManualScoreOther, p = 0.7, list = F, times = 1)]

msnModel1_85.All <- upSample85(metricsScaled.MSN.labeled, "ManualScoreOther", trainingSetMsnObjects.All, myControlUpsample, reducedFeatures.Other, timesUpsampled = 2)
# prepareForSave(msnModel1_85.All[["fittedModels"]][["extraTreesZero"]]$finalModel)
# prepareForSave(msnModel1_85.All[["fittedModels"]][["extraTreesOne"]]$finalModel)
# prepareForSave(msnModel1_85.All[["fittedModels"]][["extraTreesTwo"]]$finalModel)
# saveRDS(msnModel1_85.All, paste(dirPath, "Output/ClassifiersForMsn/modelList20221218_85up_All_MSN", sep = ""))
# 
msnModel2_85.All <- upSample85(metricsScaled.MSN.labeled, "ManualScoreOther", trainingSetMsnObjects.All, myControlUpsample, reducedFeatures.Other2, timesUpsampled = 2)
# prepareForSave(msnModel2_85.All[["fittedModels"]][["extraTreesZero"]]$finalModel)
# prepareForSave(msnModel2_85.All[["fittedModels"]][["extraTreesOne"]]$finalModel)
# prepareForSave(msnModel2_85.All[["fittedModels"]][["extraTreesTwo"]]$finalModel)
# saveRDS(msnModel2_85.All, paste(dirPath, "Output/ClassifiersForMsn/modelList20221218_85up_All_NoTexture_MSN", sep = ""))
# 
msnModel1_85.All.Balanced <- upSample85(metricsScaled.MSN.labeled, "ManualScoreOther", trainingSetMsnObjects.All.Balanced, myControlUpsample, reducedFeatures.Other, timesUpsampled = 2)
# prepareForSave(msnModel1_85.All.Balanced[["fittedModels"]][["extraTreesZero"]]$finalModel)
# prepareForSave(msnModel1_85.All.Balanced[["fittedModels"]][["extraTreesOne"]]$finalModel)
# prepareForSave(msnModel1_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]]$finalModel)
# saveRDS(msnModel1_85.All.Balanced, paste(dirPath, "Output/ClassifiersForMsn/modelList20221218_85up_All_Balanced_MSN", sep = ""))
# 
msnModel2_85.All.Balanced <- upSample85(metricsScaled.MSN.labeled, "ManualScoreOther", trainingSetMsnObjects.All.Balanced, myControlUpsample, reducedFeatures.Other2, timesUpsampled = 2)
# prepareForSave(msnModel2_85.All.Balanced[["fittedModels"]][["extraTreesZero"]]$finalModel)
# prepareForSave(msnModel2_85.All.Balanced[["fittedModels"]][["extraTreesOne"]]$finalModel)
# prepareForSave(msnModel2_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]]$finalModel)
# saveRDS(msnModel2_85.All.Balanced, paste(dirPath, "Output/ClassifiersForMsn/modelList20221218_85up_All_Balanced_NoTexture_MSN", sep = ""))
```

Load classifiers trained in the previous chunk:
```{r}
msnModel1_85.All <- readRDS(paste(dirPath, "Input/Classifiers/modelList20221218_85up_All_MSN", sep = ""))
msnModel2_85.All <- readRDS(paste(dirPath, "Input/Classifiers/modelList20221218_85up_All_NoTexture_MSN", sep = ""))
msnModel1_85.All.Balanced <- readRDS(paste(dirPath, "Input/Classifiers/modelList20221218_85up_All_Balanced_MSN", sep = ""))
msnModel2_85.All.Balanced <- readRDS(paste(dirPath, "Input/Classifiers/modelList20221218_85up_All_Balanced_NoTexture_MSN", sep = ""))
```

Accuracy
```{r}
# Classification from two rounds of upsampling without balancing per cell line
metricsClean.Classified.MSN.Two.All <- classifyCleanMetricsCombinedModels(classifyCleanMetricsCombinedModels(metricsCleanCrispr %>% 
                                                                                                               filter(str_detect(Condition, "MSN")), 
                                                                               metricsScaled.MSN, 
                                                                               msnModel2_85.All[["fittedModels"]][["gbmTwo"]],
                                                                               msnModel2_85.All[["fittedModels"]][["extraTreesTwo"]],
                                                                               "comboGbmExtraTwo_MSN2"),
                                                                           metricsScaled.MSN, 
                                                                           msnModel1_85.All[["fittedModels"]][["gbmTwo"]],
                                                                           msnModel1_85.All[["fittedModels"]][["extraTreesTwo"]],
                                                                           "comboGbmExtraTwo_MSN1") %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                mainRep = str_remove(Replicate, "_Stain.*")) %>%
  dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4")))

# Classification from two rounds of upsampling with balancing per cell line
metricsClean.Classified.MSN.Two.All.Balanced <- classifyCleanMetricsCombinedModels(classifyCleanMetricsCombinedModels(metricsCleanCrispr %>% 
                                                                                                               filter(str_detect(Condition, "MSN")), 
                                                                               metricsScaled.MSN, 
                                                                               msnModel2_85.All.Balanced[["fittedModels"]][["gbmTwo"]],
                                                                               msnModel2_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]],
                                                                               "comboGbmExtraTwo_MSN2"),
                                                                           metricsScaled.MSN, 
                                                                           msnModel1_85.All.Balanced[["fittedModels"]][["gbmTwo"]],
                                                                           msnModel1_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]],
                                                                           "comboGbmExtraTwo_MSN1") %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                mainRep = str_remove(Replicate, "_Stain.*")) %>%
  dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4")))

# Classification from one round of upsampling with balancing per cell line
metricsClean.Classified.MSN.One.All.Balanced <- classifyCleanMetricsCombinedModels(classifyCleanMetricsCombinedModels(metricsCleanCrispr %>% 
                                                                                                               filter(str_detect(Condition, "MSN")), 
                                                                               metricsScaled.MSN, 
                                                                               msnModel2_85.All.Balanced[["fittedModels"]][["gbmOne"]],
                                                                               msnModel2_85.All.Balanced[["fittedModels"]][["extraTreesOne"]],
                                                                               "comboGbmExtraOne_MSN2"),
                                                                           metricsScaled.MSN, 
                                                                           msnModel1_85.All.Balanced[["fittedModels"]][["gbmOne"]],
                                                                           msnModel1_85.All.Balanced[["fittedModels"]][["extraTreesOne"]],
                                                                           "comboGbmExtraOne_MSN1") %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                mainRep = str_remove(Replicate, "_Stain.*")) %>%
  dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4")))

# Classification from one round of upsampling without balancing per cell line
metricsClean.Classified.MSN.One.All <- classifyCleanMetricsCombinedModels(classifyCleanMetricsCombinedModels(metricsCleanCrispr %>% 
                                                                                                               filter(str_detect(Condition, "MSN")), 
                                                                               metricsScaled.MSN, 
                                                                               msnModel2_85.All[["fittedModels"]][["gbmOne"]],
                                                                               msnModel2_85.All[["fittedModels"]][["extraTreesOne"]],
                                                                               "comboGbmExtraOne_MSN2"),
                                                                           metricsScaled.MSN, 
                                                                           msnModel1_85.All[["fittedModels"]][["gbmOne"]],
                                                                           msnModel1_85.All[["fittedModels"]][["extraTreesOne"]],
                                                                           "comboGbmExtraOne_MSN1") %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                mainRep = str_remove(Replicate, "_Stain.*")) %>%
  dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4")))

# Accuracy for classifier trained on less balanced data, two rounds of upsampling, 36 features
analyzeResults2(metricsClean.Classified.MSN.Two.All %>% 
                  merge(manualTrain %>% filter(str_detect(Condition, "MSN"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% msnModel2_85.All[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_MSN2",
               "ManualScoreOther", "mainCondition")

analyzeResults2(metricsClean.Classified.MSN.Two.All %>% 
                  merge(manualTrain %>% filter(str_detect(Condition, "MSN"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% msnModel2_85.All[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_MSN2",
               "ManualScoreOther", "Experiment")

# Best classifier (two rounds of upsampling, balanced, 36 features)
analyzeResults2(metricsClean.Classified.MSN.Two.All.Balanced %>% 
                  merge(manualTrain %>% filter(str_detect(Condition, "MSN"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% msnModel2_85.All.Balanced[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_MSN2",
               "ManualScoreOther", "mainCondition")

analyzeResults2(metricsClean.Classified.MSN.Two.All.Balanced %>% 
                  merge(manualTrain %>% filter(str_detect(Condition, "MSN"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% msnModel2_85.All.Balanced[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_MSN2",
               "ManualScoreOther", "Experiment")

# Texture feature inclusion is still fairly accurate, but not quite as good as model 2 (Naive cells are less accurate)
analyzeResults2(metricsClean.Classified.MSN.Two.All.Balanced %>%
                  merge(manualTrain %>% filter(str_detect(Condition, "MSN"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% msnModel1_85.All.Balanced[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_MSN1",
               "ManualScoreOther", "mainCondition")

analyzeResults2(metricsClean.Classified.MSN.Two.All %>%
                  merge(manualTrain %>% filter(str_detect(Condition, "MSN"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% msnModel1_85.All[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_MSN1",
               "ManualScoreOther", "mainCondition")

# One round of upsampling tended to be less specific than two
analyzeResults2(metricsClean.Classified.MSN.One.All.Balanced %>%
                  merge(manualTrain %>% filter(str_detect(Condition, "MSN"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% msnModel2_85.All.Balanced[["trainingSets"]][["One"]]),
               "comboGbmExtraOne_MSN2",
               "ManualScoreOther", "mainCondition")

analyzeResults2(metricsClean.Classified.MSN.One.All %>%
                  merge(manualTrain %>% filter(str_detect(Condition, "MSN"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% msnModel2_85.All[["trainingSets"]][["One"]]),
               "comboGbmExtraOne_MSN2",
               "ManualScoreOther", "mainCondition") # Less specific
unique(manualTrain %>% filter(str_detect(Condition, "MSN"), is.na(Segmentation))) %>% count(Condition) # Check accuracy is for correct stain

```
Model2 (without Haralick texture features) is slightly more accurate than model 1 for two rounds of upsampling. Both training sets had similar accuracy but balanced training set was slightly more accurate.

Create classifier for EZR staining:
```{r}
medianAreas.EZR <- controlMedianAreas(metricsCleanCrispr %>% filter(str_detect(Condition, "EZR")),
                                      normAreaFeatures.Other,
                                      manualTrain %>% filter(str_detect(Condition, "EZR"), is.na(Segmentation)))

metricsScaled.EZR <- scaleAreaIntensity(metricsCleanCrispr %>%
  filter(str_detect(Condition, "EZR")), normAreaFeatures.Other, medianAreas.EZR, colocFeatures, "Other", "_BgSubtractedOther")

metricsScaled.EZR.labeled <- metricsScaled.EZR %>%
  merge(manualTrain %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object, Segmentation), by = "Object") %>%
  filter(str_detect(Condition, "EZR")) %>%
  filter(is.na(Segmentation)) %>%
  dplyr::select(-Segmentation)

# Check removal of images without EZR staining
identical(metricsCleanCrispr %>% filter(str_detect(Image, "EZR")) %>% dplyr::select(Object),
  metricsScaled.EZR %>% dplyr::select(Object))

# Objects for starting training set:
manualTrain.All.Balanced.EZR <- manualTrain.All.Balanced %>% filter(str_detect(Condition, "EZR"))
manualTrain.All.EZR <- manualTrain %>% filter(str_detect(Condition, "EZR")) %>% filter(is.na(Segmentation)) # Try training with more cells but unbalanced conditions

set.seed(123)
trainingSetEzrObjects.All <- manualTrain.All.EZR$Object[createDataPartition(manualTrain.All.EZR$ManualScoreOther, p = 0.7, list = F, times = 1)]
set.seed(123)
trainingSetEzrObjects.All.Balanced <- manualTrain.All.Balanced.EZR$Object[createDataPartition(manualTrain.All.Balanced.EZR$ManualScoreOther, p = 0.7, list = F, times = 1)]

ezrModel1_85.All <- upSample85(metricsScaled.EZR.labeled, "ManualScoreOther", trainingSetEzrObjects.All, myControlUpsample, reducedFeatures.Other, timesUpsampled = 2)
# prepareForSave(ezrModel1_85.All[["fittedModels"]][["extraTreesZero"]]$finalModel)
# prepareForSave(ezrModel1_85.All[["fittedModels"]][["extraTreesOne"]]$finalModel)
# prepareForSave(ezrModel1_85.All[["fittedModels"]][["extraTreesTwo"]]$finalModel)
# saveRDS(ezrModel1_85.All, paste(dirPath, "Output/ClassifiersForEzr/modelList20221218_85up_All_EZR", sep = ""))
# 
ezrModel2_85.All <- upSample85(metricsScaled.EZR.labeled, "ManualScoreOther", trainingSetEzrObjects.All, myControlUpsample, reducedFeatures.Other2, timesUpsampled = 2)
# prepareForSave(ezrModel2_85.All[["fittedModels"]][["extraTreesZero"]]$finalModel)
# prepareForSave(ezrModel2_85.All[["fittedModels"]][["extraTreesOne"]]$finalModel)
# prepareForSave(ezrModel2_85.All[["fittedModels"]][["extraTreesTwo"]]$finalModel)
# saveRDS(ezrModel2_85.All, paste(dirPath, "Output/ClassifiersForEzr/modelList20221218_85up_All_NoTexture_EZR", sep = ""))
# 
ezrModel1_85.All.Balanced <- upSample85(metricsScaled.EZR.labeled, "ManualScoreOther", trainingSetEzrObjects.All.Balanced, myControlUpsample, reducedFeatures.Other, timesUpsampled = 2)
# prepareForSave(ezrModel1_85.All.Balanced[["fittedModels"]][["extraTreesZero"]]$finalModel)
# prepareForSave(ezrModel1_85.All.Balanced[["fittedModels"]][["extraTreesOne"]]$finalModel)
# prepareForSave(ezrModel1_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]]$finalModel)
# saveRDS(ezrModel1_85.All.Balanced, paste(dirPath, "Output/ClassifiersForEzr/modelList20221218_85up_All_Balanced_EZR", sep = ""))
# 
ezrModel2_85.All.Balanced <- upSample85(metricsScaled.EZR.labeled, "ManualScoreOther", trainingSetEzrObjects.All.Balanced, myControlUpsample, reducedFeatures.Other2, timesUpsampled = 2)
# prepareForSave(ezrModel2_85.All.Balanced[["fittedModels"]][["extraTreesZero"]]$finalModel)
# prepareForSave(ezrModel2_85.All.Balanced[["fittedModels"]][["extraTreesOne"]]$finalModel)
# prepareForSave(ezrModel2_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]]$finalModel)
# saveRDS(ezrModel2_85.All.Balanced, paste(dirPath, "Output/ClassifiersForEzr/modelList20221218_85up_All_Balanced_NoTexture_EZR", sep = ""))
```

Load previously trained classifiers:
```{r}
ezrModel1_85.All <- readRDS(paste(dirPath, "Input/Classifiers/modelList20221218_85up_All_EZR", sep = ""))
ezrModel2_85.All <- readRDS(paste(dirPath, "Input/Classifiers/modelList20221218_85up_All_NoTexture_EZR", sep = ""))
ezrModel1_85.All.Balanced <- readRDS(paste(dirPath, "Input/Classifiers/modelList20221218_85up_All_Balanced_EZR", sep = ""))
ezrModel2_85.All.Balanced <- readRDS(paste(dirPath, "Input/Classifiers/modelList20221218_85up_All_Balanced_NoTexture_EZR", sep = ""))
```

```{r}
# Classification from two rounds of upsampling without balancing per cell line
metricsClean.Classified.EZR.Two.All <- classifyCleanMetricsCombinedModels(classifyCleanMetricsCombinedModels(metricsCleanCrispr %>% 
                                                                                                               filter(str_detect(Condition, "EZR")), 
                                                                               metricsScaled.EZR, 
                                                                               ezrModel2_85.All[["fittedModels"]][["gbmTwo"]],
                                                                               ezrModel2_85.All[["fittedModels"]][["extraTreesTwo"]],
                                                                               "comboGbmExtraTwo_EZR2"),
                                                                           metricsScaled.EZR, 
                                                                           ezrModel1_85.All[["fittedModels"]][["gbmTwo"]],
                                                                           ezrModel1_85.All[["fittedModels"]][["extraTreesTwo"]],
                                                                           "comboGbmExtraTwo_EZR1") %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                mainRep = str_remove(Replicate, "_Stain.*")) %>%
  dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4")))

# Classification from two rounds of upsampling with balancing per cell line
metricsClean.Classified.EZR.Two.All.Balanced <- classifyCleanMetricsCombinedModels(classifyCleanMetricsCombinedModels(metricsCleanCrispr %>% 
                                                                                                               filter(str_detect(Condition, "EZR")), 
                                                                               metricsScaled.EZR, 
                                                                               ezrModel2_85.All.Balanced[["fittedModels"]][["gbmTwo"]],
                                                                               ezrModel2_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]],
                                                                               "comboGbmExtraTwo_EZR2"),
                                                                           metricsScaled.EZR, 
                                                                           ezrModel1_85.All.Balanced[["fittedModels"]][["gbmTwo"]],
                                                                           ezrModel1_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]],
                                                                           "comboGbmExtraTwo_EZR1") %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                mainRep = str_remove(Replicate, "_Stain.*")) %>%
  dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4")))

# Classification from one round of upsampling with balancing per cell line
metricsClean.Classified.EZR.One.All.Balanced <- classifyCleanMetricsCombinedModels(classifyCleanMetricsCombinedModels(metricsCleanCrispr %>% 
                                                                                                               filter(str_detect(Condition, "EZR")), 
                                                                               metricsScaled.EZR, 
                                                                               ezrModel2_85.All.Balanced[["fittedModels"]][["gbmOne"]],
                                                                               ezrModel2_85.All.Balanced[["fittedModels"]][["extraTreesOne"]],
                                                                               "comboGbmExtraOne_EZR2"),
                                                                           metricsScaled.EZR, 
                                                                           ezrModel1_85.All.Balanced[["fittedModels"]][["gbmOne"]],
                                                                           ezrModel1_85.All.Balanced[["fittedModels"]][["extraTreesOne"]],
                                                                           "comboGbmExtraOne_EZR1") %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                mainRep = str_remove(Replicate, "_Stain.*")) %>%
  dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4")))

# Two rounds of upsampling with less balanced data, 36 features
analyzeResults2(metricsClean.Classified.EZR.Two.All %>% 
                  merge(manualTrain %>% filter(str_detect(Condition, "EZR"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% ezrModel2_85.All[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_EZR2",
               "ManualScoreOther", "mainCondition")

analyzeResults2(metricsClean.Classified.EZR.Two.All %>% 
                  merge(manualTrain %>% filter(str_detect(Condition, "EZR"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% ezrModel2_85.All[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_EZR2",
               "ManualScoreOther", "Experiment")

# Use this one (two rounds upsampling, balanced data per cell line, 36 features)
analyzeResults2(metricsClean.Classified.EZR.Two.All.Balanced %>% 
                  merge(manualTrain %>% filter(str_detect(Condition, "EZR"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% ezrModel2_85.All.Balanced[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_EZR2",
               "ManualScoreOther", "mainCondition")

analyzeResults2(metricsClean.Classified.EZR.Two.All.Balanced %>% 
                  merge(manualTrain %>% filter(str_detect(Condition, "EZR"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% ezrModel2_85.All.Balanced[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_EZR2",
               "ManualScoreOther", "Experiment")

# Including texture features
analyzeResults2(metricsClean.Classified.EZR.Two.All.Balanced %>%
                  merge(manualTrain %>% filter(str_detect(Condition, "EZR"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% ezrModel1_85.All.Balanced[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_EZR1",
               "ManualScoreOther", "mainCondition") # A little less sensitive

# One round of upsampling
analyzeResults2(metricsClean.Classified.EZR.One.All.Balanced %>%
                  merge(manualTrain %>% filter(str_detect(Condition, "EZR"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% ezrModel2_85.All.Balanced[["trainingSets"]][["One"]]),
               "comboGbmExtraOne_EZR2",
               "ManualScoreOther", "mainCondition") # Less specific except for KKGK3

# One round of upsampling
analyzeResults2(metricsClean.Classified.EZR.One.All.Balanced %>%
                  merge(manualTrain %>% filter(str_detect(Condition, "EZR"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% ezrModel2_85.All.Balanced[["trainingSets"]][["One"]]),
               "comboGbmExtraOne_EZR2",
               "ManualScoreOther", "Experiment") # Less specific and sensitive

unique(manualTrain %>% filter(str_detect(Condition, "EZR"), is.na(Segmentation))) %>% count(Condition) # Check accuracy is for correct stain
```
Training with balanced starting set was very similar in accuracy to unbalanced. Decided to use balanced training set model for consistency with MSN. (modelList20221218_85up_All_Balanced_NoTexture_EZR)

Train a classifier for pERM (Phospho-ERM) staining:
```{r}
medianAreas.pERM <- controlMedianAreas(metricsCleanCrispr %>% filter(str_detect(Condition, "pERM")), 
                                      normAreaFeatures.Other, 
                                      manualTrain %>% filter(str_detect(Condition, "pERM"), is.na(Segmentation)))

metricsScaled.pERM <- scaleAreaIntensity(metricsCleanCrispr %>%
  filter(str_detect(Condition, "pERM")), normAreaFeatures.Other, medianAreas.pERM, colocFeatures, "Other", "_BgSubtractedOther")

metricsScaled.pERM.labeled <- metricsScaled.pERM %>%
  merge(manualTrain %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object, Segmentation), by = "Object") %>%
  filter(str_detect(Condition, "pERM")) %>%
  filter(is.na(Segmentation)) %>%
  dplyr::select(-Segmentation)

# Check removal of images without pERM staining
identical(metricsCleanCrispr %>% filter(str_detect(Image, "pERM")) %>% dplyr::select(Object),
  metricsScaled.pERM %>% dplyr::select(Object))

# Objects for starting training set:
manualTrain.All.Balanced.pERM <- manualTrain.All.Balanced %>% filter(str_detect(Condition, "pERM"))

set.seed(123)
trainingSetPermObjects.All.Balanced <- manualTrain.All.Balanced.pERM$Object[createDataPartition(manualTrain.All.Balanced.pERM$ManualScoreOther, p = 0.7, list = F, times = 1)]

permModel1_85.All.Balanced <- upSample85(metricsScaled.pERM.labeled, "ManualScoreOther", trainingSetPermObjects.All.Balanced, myControlUpsample, reducedFeatures.Other, timesUpsampled = 2)
# prepareForSave(permModel1_85.All.Balanced[["fittedModels"]][["extraTreesZero"]]$finalModel)
# prepareForSave(permModel1_85.All.Balanced[["fittedModels"]][["extraTreesOne"]]$finalModel)
# prepareForSave(permModel1_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]]$finalModel)
# saveRDS(permModel1_85.All.Balanced, paste(dirPath, "Output/ClassifiersForPerm/modelList20221218_85up_All_Balanced_pERM", sep = ""))
# 
permModel2_85.All.Balanced <- upSample85(metricsScaled.pERM.labeled, "ManualScoreOther", trainingSetPermObjects.All.Balanced, myControlUpsample, reducedFeatures.Other2, timesUpsampled = 2)
# prepareForSave(permModel2_85.All.Balanced[["fittedModels"]][["extraTreesZero"]]$finalModel)
# prepareForSave(permModel2_85.All.Balanced[["fittedModels"]][["extraTreesOne"]]$finalModel)
# prepareForSave(permModel2_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]]$finalModel)
# saveRDS(permModel2_85.All.Balanced, paste(dirPath, "Output/ClassifiersForPerm/modelList20221218_85up_All_Balanced_NoTexture_pERM", sep = ""))
```

Load previously trained classifiers:
```{r}
permModel1_85.All.Balanced <- readRDS(paste(dirPath, "Input/Classifiers/modelList20221218_85up_All_Balanced_pERM", sep = ""))
permModel2_85.All.Balanced <- readRDS(paste(dirPath, "Input/Classifiers/modelList20221218_85up_All_Balanced_NoTexture_pERM", sep = ""))
```

Accuracy:
```{r}
# Classification from two rounds of upsampling with balancing per cell line
metricsClean.Classified.pERM.Two.All.Balanced <- classifyCleanMetricsCombinedModels(classifyCleanMetricsCombinedModels(metricsCleanCrispr %>% 
                                                                                                               filter(str_detect(Condition, "pERM")), 
                                                                               metricsScaled.pERM, 
                                                                               permModel2_85.All.Balanced[["fittedModels"]][["gbmTwo"]],
                                                                               permModel2_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]],
                                                                               "comboGbmExtraTwo_pERM2"),
                                                                           metricsScaled.pERM, 
                                                                           permModel1_85.All.Balanced[["fittedModels"]][["gbmTwo"]],
                                                                           permModel1_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]],
                                                                           "comboGbmExtraTwo_pERM1") %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                mainRep = str_remove(Replicate, "_Stain.*")) %>%
  dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4")))

# Classification from one round of upsampling with balancing per cell line
metricsClean.Classified.pERM.One.All.Balanced <- classifyCleanMetricsCombinedModels(classifyCleanMetricsCombinedModels(metricsCleanCrispr %>% 
                                                                                                               filter(str_detect(Condition, "pERM")), 
                                                                               metricsScaled.pERM, 
                                                                               permModel2_85.All.Balanced[["fittedModels"]][["gbmOne"]],
                                                                               permModel2_85.All.Balanced[["fittedModels"]][["extraTreesOne"]],
                                                                               "comboGbmExtraOne_pERM2"),
                                                                           metricsScaled.pERM, 
                                                                           permModel1_85.All.Balanced[["fittedModels"]][["gbmOne"]],
                                                                           permModel1_85.All.Balanced[["fittedModels"]][["extraTreesOne"]],
                                                                           "comboGbmExtraOne_pERM1") %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                mainRep = str_remove(Replicate, "_Stain.*")) %>%
  dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4")))

# Use this one: (Two rounds upsampling, balanced data per cell line, 36 features)
analyzeResults2(metricsClean.Classified.pERM.Two.All.Balanced %>% 
                  merge(manualTrain %>% filter(str_detect(Condition, "pERM"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% permModel2_85.All.Balanced[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_pERM2",
               "ManualScoreOther", "mainCondition")

analyzeResults2(metricsClean.Classified.pERM.Two.All.Balanced %>% 
                  merge(manualTrain %>% filter(str_detect(Condition, "pERM"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% permModel2_85.All.Balanced[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_pERM2",
               "ManualScoreOther", "Experiment")

# Model 1 (including texture features)
analyzeResults2(metricsClean.Classified.pERM.Two.All.Balanced %>%
                  merge(manualTrain %>% filter(str_detect(Condition, "pERM"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% permModel1_85.All.Balanced[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_pERM1",
               "ManualScoreOther", "mainCondition") # Lower sensitivity

# One round of upsampling - essentially equivalent accuracy to two rounds. I will use two rounds for consistency.
analyzeResults2(metricsClean.Classified.pERM.One.All.Balanced %>%
                  merge(manualTrain %>% filter(str_detect(Condition, "pERM"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% permModel2_85.All.Balanced[["trainingSets"]][["One"]]),
               "comboGbmExtraOne_pERM2",
               "ManualScoreOther", "mainCondition")

analyzeResults2(metricsClean.Classified.pERM.One.All.Balanced %>%
                  merge(manualTrain %>% filter(str_detect(Condition, "pERM"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% permModel2_85.All.Balanced[["trainingSets"]][["One"]]),
               "comboGbmExtraOne_pERM2",
               "ManualScoreOther", "Experiment")

unique(manualTrain %>% filter(str_detect(Condition, "pERM"), is.na(Segmentation))) %>% count(Condition) # Check accuracy is for correct stain
```
Second round of upsampling for Model 2 is the best.

Score more cells to make a RDX classifier:
```{r}
# metricsClean.Classified.MCAM.Two.All %>% filter(str_detect(Condition, "RDX")) %>% group_by(Condition, Experiment) %>% count(comboGbmExtraTwo_MCAM2)
# trainingObjects3 <- rbind(metricsClean.Classified.MCAM.Two.All %>%
#                            filter(!Object %in% manualTrain$Object) %>%
#                            filter(str_detect(Condition, "RDX")) %>% # Don't score any more from this staining set
#                            group_by(comboGbmExtraTwo_MCAM2, Experiment, Condition) %>% # Get about the same number of cells per experiment and staining condition
#                            filter(comboGbmExtraTwo_MCAM2 != "BothEnds") %>%
#                            slice_sample(n = 50, replace = F) %>%
#                             ungroup(),
#                          metricsClean.Classified.MCAM.Two.All %>%
#                            filter(!Object %in% manualTrain$Object) %>%
#                            filter(str_detect(Condition, "RDX")) %>%
#                            filter(comboGbmExtraTwo_MCAM2 == "BothEnds")) %>% # Take all of the "BothEnds" classes as this is a small proportion of cells
#                            dplyr::select(comboGbmExtraTwo_MCAM2, Object)
# 
# write_csv(trainingObjects3, paste(dirPath, "Output/trainingSet3_20221218.csv", sep = ""))
# trainingObjects3 <- read.csv(paste(dirPath, "Output/trainingSet3_20221218.csv", sep = ""))
# 
# # Shuffle cells
# nCells <- length(trainingObjects3$Object)
# set.seed(123)
# fileNameV1 <- paste(gsub(".nd2", "_Img_Cell", trainingObjects3$Object)[sample(nCells, nCells, replace = F)], "_80thPctlNoClose.png", sep = "")
# fileNameV2 <- gsub("_80thPctlNoClose.png", "_Img_Cell_80thPctlNoClose.png", gsub("_Img_Cell", "", fileNameV1))
# 
# renameMatrix <- data.frame(newNum = 1:(nCells), imgNameV1 = fileNameV1, imgNameV2 = fileNameV2) %>%
#   dplyr::mutate(newNameImg = paste("80thPctlNoClose_", as.character(newNum), "_Img.png", sep = ""),
#          newNameFig = paste("80thPctlNoClose_", as.character(newNum), "_Fig.png", sep = ""),
#          figNameV1 = paste("Bg_", str_replace(imgNameV1, "Img", "Figure"), sep = ""),
#          figNameV2 = str_replace(imgNameV2, "Img", "Figure")) %>%
#    dplyr::mutate(pathNameImgV1 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/", imgNameV1, sep = ""),
#           pathNameImgV2 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/", imgNameV2, sep = ""),
#           pathNameFigV1 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/", figNameV1, sep = ""),
#           pathNameFigV2 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/", figNameV2, sep = "")) %>%
#   dplyr::mutate(toPathNameImgV1 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/TrainingSet3/", imgNameV1, sep = ""),
#           toPathNameImgV2 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/TrainingSet3/", imgNameV2, sep = ""),
#           toPathNameFigV1 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/TrainingSet3/", figNameV1, sep = ""),
#           toPathNameFigV2 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/TrainingSet3/", figNameV2, sep = ""))


# 
# file.copy(from = renameMatrix$pathNameImgV1, to = renameMatrix$toPathNameImgV1)
# file.copy(from = renameMatrix$pathNameImgV2, to = renameMatrix$toPathNameImgV2)
# file.copy(from = renameMatrix$pathNameFigV1, to = renameMatrix$toPathNameFigV1)
# file.copy(from = renameMatrix$pathNameFigV2, to = renameMatrix$toPathNameFigV2)
# 
# setwd(paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/TrainingSet3/", sep = ""))
# write.csv(renameMatrix, "Blinding_TrainingSet3_20221218.csv")
# file.rename(renameMatrix$imgNameV1, renameMatrix$newNameImg)
# file.rename(renameMatrix$imgNameV2, renameMatrix$newNameImg)
# file.rename(renameMatrix$figNameV1, renameMatrix$newNameFig)
# file.rename(renameMatrix$figNameV2, renameMatrix$newNameFig)
```

RDX polarization classifier:
```{r}
medianAreas.RDX <- controlMedianAreas(metricsCleanCrispr %>% filter(str_detect(Condition, "RDX")), 
                                      normAreaFeatures.Other, 
                                      manualTrain %>% filter(str_detect(Condition, "RDX"), is.na(Segmentation)))

metricsScaled.RDX <- scaleAreaIntensity(metricsCleanCrispr %>%
  filter(str_detect(Condition, "RDX")), normAreaFeatures.Other, medianAreas.RDX, colocFeatures, "Other", "_BgSubtractedOther")

# Objects for starting training set:
manualTrain3 <- read.csv(paste(dirPath, "Input/manualScoringTrainingSet3_20221218.csv", sep = ""))
intersect(manualTrain3$Object, manualTrain$Object) # Check for duplicate objects
manualTrainUpdated <- rbind(manualTrain, manualTrain3)
sum(duplicated(manualTrainUpdated$Object)) 
manualTrainUpdated %>% filter(str_detect(Condition, "RDX")) %>% group_by(Experiment) %>% count(Condition) %>% ungroup()

metricsScaled.RDX.labeled <- metricsScaled.RDX %>%
  merge(manualTrainUpdated %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object, Segmentation, WrongObject), by = "Object") %>%
  filter(str_detect(Condition, "RDX")) %>%
  filter(is.na(Segmentation)) %>% # Don't filter WrongObject; brightest object is wrong for most cells with OneEnd b/c of nuclear stain
  dplyr::select(-Segmentation, -WrongObject)

# Check removal of images without RDX staining
identical(metricsCleanCrispr %>% filter(str_detect(Image, "RDX")) %>% dplyr::select(Object),
  metricsScaled.RDX %>% dplyr::select(Object))

manualTrain.All.Balanced.RDX <- manualTrainUpdated %>%
  filter(str_detect(Condition, "RDX")) %>%
  group_by(Condition) %>%
  slice_sample(n = 152, replace = F) %>%
  ungroup() %>%
  filter(is.na(Segmentation))
unique(manualTrain.All.Balanced.RDX$Condition)
manualTrain.All.Balanced.RDX %>% group_by(Experiment) %>% count(Condition) %>% ungroup()

# write_csv(manualTrain.All.Balanced.RDX, paste(dirPath, "Output/BalancedManualScoring_RDX_20221218.csv", sep=""))
manualTrain.All.Balanced.RDX <- read.csv(paste("Input/BalancedManualScoring_RDX_20221218.csv", sep=""))
# 
set.seed(123)
trainingSetRdxObjects.All.Balanced <- manualTrain.All.Balanced.RDX$Object[createDataPartition(manualTrain.All.Balanced.RDX$ManualScoreOther, p = 0.7, list = F, times = 1)]

rdxModel1_85.All.Balanced <- upSample85(metricsScaled.RDX.labeled, "ManualScoreOther", trainingSetRdxObjects.All.Balanced, myControlUpsample, reducedFeatures.Other, timesUpsampled = 2)
# prepareForSave(rdxModel1_85.All.Balanced[["fittedModels"]][["extraTreesZero"]]$finalModel)
# prepareForSave(rdxModel1_85.All.Balanced[["fittedModels"]][["extraTreesOne"]]$finalModel)
# prepareForSave(rdxModel1_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]]$finalModel)
# saveRDS(rdxModel1_85.All.Balanced, paste(dirPath, "Output/ClassifiersForRdx/modelList20221217_85up_All_Balanced_RDX", sep = ""))
# 
rdxModel2_85.All.Balanced <- upSample85(metricsScaled.RDX.labeled, "ManualScoreOther", trainingSetRdxObjects.All.Balanced, myControlUpsample, reducedFeatures.Other2, timesUpsampled = 2)
# prepareForSave(rdxModel2_85.All.Balanced[["fittedModels"]][["extraTreesZero"]]$finalModel)
# prepareForSave(rdxModel2_85.All.Balanced[["fittedModels"]][["extraTreesOne"]]$finalModel)
# prepareForSave(rdxModel2_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]]$finalModel)
# saveRDS(rdxModel2_85.All.Balanced, paste(dirPath, "Output/ClassifiersForRdx/modelList20221217_85up_All_Balanced_NoTexture_RDX", sep = ""))
```

Load previously trained classifiers:
```{r}
rdxModel1_85.All.Balanced <- readRDS(paste(dirPath, "Input/Classifiers/modelList20221217_85up_All_Balanced_RDX", sep = ""))
rdxModel2_85.All.Balanced <- readRDS(paste(dirPath, "Input/Classifiers/modelList20221217_85up_All_Balanced_NoTexture_RDX", sep = ""))
```

Accuracy of combined classifiers for RDX:
```{r}
# Classification from two rounds of upsampling with balancing per cell line
metricsClean.Classified.RDX.Two.All.Balanced <- classifyCleanMetricsCombinedModels(classifyCleanMetricsCombinedModels(metricsCleanCrispr %>% 
                                                                                                               filter(str_detect(Condition, "RDX")), 
                                                                               metricsScaled.RDX, 
                                                                               rdxModel2_85.All.Balanced[["fittedModels"]][["gbmTwo"]],
                                                                               rdxModel2_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]],
                                                                               "comboGbmExtraTwo_RDX2"),
                                                                           metricsScaled.RDX, 
                                                                           rdxModel1_85.All.Balanced[["fittedModels"]][["gbmTwo"]],
                                                                           rdxModel1_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]],
                                                                           "comboGbmExtraTwo_RDX1") %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                mainRep = str_remove(Replicate, "_Stain.*")) %>%
  dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4")))

# Classification from one round of upsampling with balancing per cell line
metricsClean.Classified.RDX.One.All.Balanced <- classifyCleanMetricsCombinedModels(classifyCleanMetricsCombinedModels(metricsCleanCrispr %>% 
                                                                                                               filter(str_detect(Condition, "RDX")), 
                                                                               metricsScaled.RDX, 
                                                                               rdxModel2_85.All.Balanced[["fittedModels"]][["gbmOne"]],
                                                                               rdxModel2_85.All.Balanced[["fittedModels"]][["extraTreesOne"]],
                                                                               "comboGbmExtraOne_RDX2"),
                                                                           metricsScaled.RDX, 
                                                                           rdxModel1_85.All.Balanced[["fittedModels"]][["gbmOne"]],
                                                                           rdxModel1_85.All.Balanced[["fittedModels"]][["extraTreesOne"]],
                                                                           "comboGbmExtraOne_RDX1") %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                mainRep = str_remove(Replicate, "_Stain.*")) %>%
  dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4")))

# Best (but not as good as classification of other proteins)
analyzeResults2(metricsClean.Classified.RDX.Two.All.Balanced %>%
                  merge(manualTrainUpdated %>% filter(str_detect(Condition, "RDX"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% rdxModel2_85.All.Balanced[["trainingSets"]][["Two"]]), "comboGbmExtraTwo_RDX2", "ManualScoreOther", "mainCondition")

analyzeResults2(metricsClean.Classified.RDX.Two.All.Balanced %>%
                  merge(manualTrainUpdated %>% filter(str_detect(Condition, "RDX"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% rdxModel2_85.All.Balanced[["trainingSets"]][["Two"]]), "comboGbmExtraTwo_RDX2", "ManualScoreOther", "Experiment")

# One round of upsample
analyzeResults2(metricsClean.Classified.RDX.One.All.Balanced %>%
                  merge(manualTrainUpdated %>% filter(str_detect(Condition, "RDX"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% rdxModel2_85.All.Balanced[["trainingSets"]][["One"]]), "comboGbmExtraOne_RDX2", "ManualScoreOther", "mainCondition") # Less accurate

# Including texture features
analyzeResults2(metricsClean.Classified.RDX.Two.All.Balanced %>%
                  merge(manualTrainUpdated %>% filter(str_detect(Condition, "RDX"), is.na(Segmentation)) %>% dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% rdxModel1_85.All.Balanced[["trainingSets"]][["Two"]]), "comboGbmExtraTwo_RDX1", "ManualScoreOther", "mainCondition") # Low sensitivity

unique(manualTrainUpdated %>% filter(str_detect(Condition, "RDX"), is.na(Segmentation)))  %>% count(Condition) # Check accuracy is for correct stain
```
ML classification of radixin can classify polarized cells reasonably well, even with the off-target nuclear signal from the antibody. However, specificity was lower than for other proteins, and this classification was not included in the paper.

Final classification and save outputs:
```{r}
# write_csv(manualTrainUpdated, paste(dirPath, "Output/combinedManualTraining_3TrainintSets.csv", sep = ""))

# write_csv(metricsCleanCrispr,  paste(dirPath, "Output/metricsCleanCrispr_20221218.csv", sep = ""))

## MCAM classification for all cells
metricsClean.Classified.MCAM.Final <- classifyCleanMetricsCombinedModels(metricsCleanCrispr, 
                                                                               metricsScaled.MCAM, 
                                                                               mcamModel2_85.All[["fittedModels"]][["gbmTwo"]],
                                                                               mcamModel2_85.All[["fittedModels"]][["extraTreesTwo"]],
                                                                               "comboGbmExtraTwo_MCAM2")
nrow(metricsClean.Classified.MCAM.Final) == nrow(metricsClean.Classified.MCAM.Final %>% filter(str_detect(Image, "MCAM")))

# write_csv(metricsClean.Classified.MCAM.Final, paste(dirPath, "Output/metricsClean_Classified_MCAM_20221218.csv", sep = ""))

# Variable importance
impGbm <- varImp(mcamModel2_85.All[["fittedModels"]][["gbmTwo"]])
# write.csv(impGbm[["importance"]], paste(dirPath, "Output/VariableImportance_Gbm_MCAM.csv", sep = ""))
impTrees <- varImp(mcamModel2_85.All[["fittedModels"]][["extraTreesTwo"]])
# write.csv(impTrees[["importance"]], paste(dirPath, "Output/VariableImportance_ExtraTrees_MCAM.csv", sep = ""))
remove(impGbm)
remove(impTrees)


## MSN classification for cells with MSN staining
metricsClean.Classified.MSN.Final <- classifyCleanMetricsCombinedModels(metricsCleanCrispr %>% 
                                                                                                               filter(str_detect(Condition, "MSN")), 
                                                                               metricsScaled.MSN, 
                                                                               msnModel2_85.All.Balanced[["fittedModels"]][["gbmTwo"]],
                                                                               msnModel2_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]],
                                                                               "comboGbmExtraTwo_MSN2")
nrow(metricsClean.Classified.MSN.Final) == nrow(metricsClean.Classified.MSN.Final %>% filter(str_detect(Image, "MSN")))

# write_csv(metricsClean.Classified.MSN.Final, paste(dirPath, "Output/metricsClean_Classified_MSN_20221218.csv", sep = ""))
# write_csv(medianAreas.MSN, paste(dirPath, "Output/MedianAreasForERMClassification/medianAreas_MSN_20221218.csv", sep = ""))

impGbm <- varImp(msnModel2_85.All.Balanced[["fittedModels"]][["gbmTwo"]])
# write.csv(impGbm[["importance"]], paste(dirPath, "Output/VariableImportance_Gbm_MSN.csv", sep = ""))
impTrees <- varImp(msnModel2_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]])
# write.csv(impTrees[["importance"]], paste(dirPath, "Output/VariableImportance_ExtraTrees_MSN.csv", sep = ""))
remove(impGbm)
remove(impTrees)

# EZR classification for cells with EZR staining
metricsClean.Classified.EZR.Final <- classifyCleanMetricsCombinedModels(metricsCleanCrispr %>% 
                                                                                                               filter(str_detect(Condition, "EZR")), 
                                                                               metricsScaled.EZR, 
                                                                               ezrModel2_85.All.Balanced[["fittedModels"]][["gbmTwo"]],
                                                                               ezrModel2_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]],
                                                                               "comboGbmExtraTwo_EZR2")
nrow(metricsClean.Classified.EZR.Final) == nrow(metricsClean.Classified.EZR.Final %>% filter(str_detect(Image, "EZR")))

# write_csv(metricsClean.Classified.EZR.Final, paste(dirPath, "Output/metricsClean_Classified_EZR_20221218.csv", sep = ""))
# write_csv(medianAreas.EZR, paste(dirPath, "Output/MedianAreasForERMClassification/medianAreas_EZR_20221218.csv", sep = ""))

impGbm <- varImp(ezrModel2_85.All.Balanced[["fittedModels"]][["gbmTwo"]])
# write.csv(impGbm[["importance"]], paste(dirPath, "Output/VariableImportance_Gbm_EZR.csv", sep = ""))
impTrees <- varImp(ezrModel2_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]])
# write.csv(impTrees[["importance"]], paste(dirPath, "Output/VariableImportance_ExtraTrees_EZR.csv", sep = ""))
remove(impGbm)
remove(impTrees)


# pERM classification for cells with pERM staining
metricsClean.Classified.pERM.Final <- classifyCleanMetricsCombinedModels(metricsCleanCrispr %>% 
                                                                                                               filter(str_detect(Condition, "pERM")), 
                                                                               metricsScaled.pERM, 
                                                                               permModel2_85.All.Balanced[["fittedModels"]][["gbmTwo"]],
                                                                               permModel2_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]],
                                                                               "comboGbmExtraTwo_pERM2")
nrow(metricsClean.Classified.pERM.Final) == nrow(metricsClean.Classified.pERM.Final %>% filter(str_detect(Image, "pERM")))

# write_csv(metricsClean.Classified.pERM.Final, paste(dirPath, "Output/metricsClean_Classified_pERM_20221218.csv", sep = ""))
# write_csv(medianAreas.pERM, paste(dirPath, "Output/MedianAreasForERMClassification/medianAreas_pERM_20221218.csv", sep = ""))
 
impGbm <- varImp(permModel2_85.All.Balanced[["fittedModels"]][["gbmTwo"]])
# write.csv(impGbm[["importance"]], paste(dirPath, "Output/VariableImportance_Gbm_pERM.csv", sep = ""))
impTrees <- varImp(permModel2_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]])
# write.csv(impTrees[["importance"]], paste(dirPath, "Output/VariableImportance_ExtraTrees_pERM.csv", sep = ""))
remove(impGbm)
remove(impTrees)


# RDX classification for Cells with RDX staining
metricsClean.Classified.RDX.Final <- classifyCleanMetricsCombinedModels(metricsCleanCrispr %>% 
                                                                                                               filter(str_detect(Condition, "RDX")), 
                                                                               metricsScaled.RDX, 
                                                                               rdxModel2_85.All.Balanced[["fittedModels"]][["gbmTwo"]],
                                                                               rdxModel2_85.All.Balanced[["fittedModels"]][["extraTreesTwo"]],
                                                                               "comboGbmExtraTwo_RDX2")
nrow(metricsClean.Classified.RDX.Final) == nrow(metricsClean.Classified.RDX.Final %>% filter(str_detect(Image, "RDX")))

# write_csv(metricsClean.Classified.RDX.Final, paste(dirPath, "Output/metricsClean_Classified_RDX_20221218.csv", sep = ""))
# write_csv(medianAreas.RDX, paste(dirPath, "Output/MedianAreasForERMClassification/medianAreas_RDX_20221218.csv", sep = ""))
```

Accuracy with trainingSet #3 included (reported in Supplemental):
MCAM accuracy:
```{r}
manualTrainTest <- manualTrainUpdated %>% filter(is.na(Segmentation))
analyzeResults2(metricsClean.Classified.MCAM.Final %>% 
                  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                                mainRep = str_remove(Replicate, "_Stain.*")) %>%
                  merge(manualTrainTest %>% 
                          dplyr::select(ManualScoreMcam, ConfidenceMcam, Object), by = "Object") %>%
                  filter(!Object %in% mcamModel2_85.All[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_MCAM2",
               "ManualScoreMcam", "mainCondition")
length(mcamModel2_85.All[["trainingSets"]][["Two"]])

metricsClean.Classified.MCAM.Final %>% 
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*")) %>%
       filter(!Object %in% mcamModel2_85.All[["trainingSets"]][["Two"]], 
              Object %in% manualTrainTest$Object) %>%
  count(mainCondition)

analyzeResults2(metricsClean.Classified.MCAM.Final %>% 
                  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                                mainRep = str_remove(Replicate, "_Stain.*")) %>%
                  merge(manualTrainTest %>% 
                          dplyr::select(ManualScoreMcam, ConfidenceMcam, Object), by = "Object") %>%
                  filter(!Object %in% mcamModel2_85.All[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_MCAM2",
               "ManualScoreMcam", "mainRep")

metricsClean.Classified.MCAM.Final %>% 
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"), mainRep = str_remove(Replicate, "_Stain.*")) %>%
       filter(!Object %in% mcamModel2_85.All[["trainingSets"]][["Two"]], 
              Object %in% manualTrainTest$Object) %>%
  count(mainRep)

analyzeResults2(metricsClean.Classified.MCAM.Final %>% 
                  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*")) %>%
                  merge(manualTrainTest %>% filter(is.na(Segmentation)) %>% 
                          dplyr::select(ManualScoreMcam, ConfidenceMcam, Object), by = "Object") %>%
                  filter(!Object %in% mcamModel2_85.All[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_MCAM2",
               "ManualScoreMcam", "Experiment")

metricsClean.Classified.MCAM.Final %>% 
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*")) %>%
       filter(!Object %in% mcamModel2_85.All[["trainingSets"]][["Two"]], 
              Object %in% manualTrainTest$Object) %>%
  count(Experiment)
```

MSN accuracy
```{r}
analyzeResults2(metricsClean.Classified.MSN.Final %>% 
                  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),mainRep = str_remove(Replicate, "_Stain.*")) %>%
                  merge(manualTrainTest %>% 
                          dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% msnModel2_85.All.Balanced[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_MSN2",
               "ManualScoreOther", "mainCondition")
length(msnModel2_85.All.Balanced[["trainingSets"]][["Two"]])

metricsClean.Classified.MSN.Final %>% 
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*")) %>%
       filter(!Object %in% msnModel2_85.All.Balanced[["trainingSets"]][["Two"]], 
              Object %in% manualTrainTest$Object) %>%
  count(mainCondition)

analyzeResults2(metricsClean.Classified.MSN.Final %>% 
                  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*")) %>%
                  merge(manualTrainTest %>% filter(is.na(Segmentation)) %>% 
                          dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% msnModel2_85.All.Balanced[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_MSN2",
               "ManualScoreOther", "Experiment")

metricsClean.Classified.MSN.Final %>% 
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*")) %>%
       filter(!Object %in% msnModel2_85.All.Balanced[["trainingSets"]][["Two"]], 
              Object %in% manualTrainTest$Object) %>%
  count(Experiment)

analyzeResults2(metricsClean.Classified.MSN.Final %>% 
                  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),mainRep = str_remove(Replicate, "_Stain.*")) %>%
                  merge(manualTrainTest %>% 
                          dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% msnModel2_85.All.Balanced[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_MSN2",
               "ManualScoreOther", "mainRep")
```

EZR accuracy
```{r}
analyzeResults2(metricsClean.Classified.EZR.Final %>% 
                  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*")) %>%
                  merge(manualTrainTest %>% 
                          dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% ezrModel2_85.All.Balanced[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_EZR2",
               "ManualScoreOther", "mainCondition")
length(ezrModel2_85.All.Balanced[["trainingSets"]][["Two"]])

metricsClean.Classified.EZR.Final %>% 
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*")) %>%
       filter(!Object %in% ezrModel2_85.All.Balanced[["trainingSets"]][["Two"]], 
              Object %in% manualTrainTest$Object) %>%
  count(mainCondition)

analyzeResults2(metricsClean.Classified.EZR.Final %>% 
                  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*")) %>%
                  merge(manualTrainTest %>% filter(is.na(Segmentation)) %>% 
                          dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% ezrModel2_85.All.Balanced[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_EZR2",
               "ManualScoreOther", "Experiment")

metricsClean.Classified.EZR.Final %>% 
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*")) %>%
       filter(!Object %in% ezrModel2_85.All.Balanced[["trainingSets"]][["Two"]], 
              Object %in% manualTrainTest$Object) %>%
  count(Experiment)
```

pERM accuracy
```{r}
analyzeResults2(metricsClean.Classified.pERM.Final %>% 
                  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*")) %>%
                  merge(manualTrainTest %>% 
                          dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% permModel2_85.All.Balanced[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_pERM2",
               "ManualScoreOther", "mainCondition")
length(permModel2_85.All.Balanced[["trainingSets"]][["Two"]])

metricsClean.Classified.pERM.Final %>% 
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*")) %>%
       filter(!Object %in% permModel2_85.All.Balanced[["trainingSets"]][["Two"]], 
              Object %in% manualTrainTest$Object) %>%
  count(mainCondition)

analyzeResults2(metricsClean.Classified.pERM.Final %>% 
                  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*")) %>%
                  merge(manualTrainTest %>% filter(is.na(Segmentation)) %>% 
                          dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% permModel2_85.All.Balanced[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_pERM2",
               "ManualScoreOther", "Experiment")

metricsClean.Classified.pERM.Final %>% 
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*")) %>%
       filter(!Object %in% permModel2_85.All.Balanced[["trainingSets"]][["Two"]], 
              Object %in% manualTrainTest$Object) %>%
  count(Experiment)

analyzeResults2(metricsClean.Classified.pERM.Final %>% 
                  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*")) %>%
                  merge(manualTrainTest %>% filter(is.na(Segmentation)) %>% 
                          dplyr::select(ManualScoreOther, ConfidenceOther, Object), by = "Object") %>%
                  filter(!Object %in% permModel2_85.All.Balanced[["trainingSets"]][["Two"]]),
               "comboGbmExtraTwo_pERM2",
               "ManualScoreOther", "Experiment")

metricsClean.Classified.pERM.Final %>% 
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*")) %>%
       filter(!Object %in% permModel2_85.All.Balanced[["trainingSets"]][["Two"]], 
              Object %in% manualTrainTest$Object) %>%
  count(Experiment)
```


Figures:

Plot the proportion of polarized cells (before and after normalization to controls):
Function to make plots:
```{r}
plotPolarSave <- function(metrics.Classified, className, title){
    percWramp.All <- metrics.Classified %>%
    dplyr::rename(classification = className) %>%
    dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                    mainRep = str_remove(Replicate, "_Stain.*")) %>%
                    dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4"))) %>%
    dplyr::select(Experiment, mainCondition, mainRep, classification) %>%
    group_by(Experiment, mainCondition, mainRep) %>%
      count(classification) %>%
    dplyr::mutate(perc = n/sum(n)*100, nTot = sum(n)) %>%
    ungroup() %>%
    filter(classification == "OneEnd")
  # write_csv(percWramp.All, paste(dirPath, "Output/Test/percPolarized_", title, ".csv", sep = ""))
   
  bioMean <- percWramp.All %>%
    group_by(mainCondition) %>%
    summarize(mean = mean(perc), sd = sd(perc)) %>%
    ungroup()
  
  print(metrics.Classified %>%
          dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                    mainRep = str_remove(Replicate, "_Stain.*")) %>%
                    dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4"))) %>%
          count(mainCondition))
  print(metrics.Classified %>% 
          dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                    mainRep = str_remove(Replicate, "_Stain.*")) %>%
                    dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4"))) %>%
          count(mainRep))
  
  percWramp.All.Norm <- percWramp.All %>%
    dplyr::select(-n, -mainRep, -nTot) %>%
    dplyr::mutate(mainCondition = as.character(mainCondition)) %>%
    spread(mainCondition, perc) %>%
    dplyr::mutate(KKGK3 = KKGK3/Naive, KKGK4 = KKGK4/Naive, Naive = Naive/Naive) %>%
    gather(key = "mainCondition", value = "perc", -Experiment, -classification) %>%
    dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4")))

  # write_csv(percWramp.All.Norm, paste(dirPath, "Output/Test/percPolarized_Normalized_", title, ".csv", sep = ""))
            
  bioMeanNorm <- percWramp.All.Norm %>%
    group_by(mainCondition) %>%
    summarize(mean = mean(perc), sd = sd(perc)) %>%
    ungroup()
  
  print(ggplot() +
        geom_col(data = bioMean, aes(x = mainCondition, y = mean),  position = position_dodge(), width = 0.5) +
        geom_point(data = percWramp.All, aes(x = mainCondition, y = perc, color = Experiment), 
                   position = position_jitterdodge(dodge.width = .3, jitter.width = 0.1, jitter.height = 0),
                  size = 2) +
        geom_errorbar(data = bioMean, aes(x = mainCondition, ymin = mean-sd, ymax = mean+sd),
                      position = position_dodge(width = .5), 
                      width = 0.25,
                      alpha = 0.5) +
        theme_classic() +
        ylab("Polarized Cells (%)") +
        ggtitle(title) +
        ylim(0,70) +
        theme(text = element_text(size = 14)))
 # ggsave(paste(dirPath, "Output/Test/percPolarized_", title, ".svg", sep = ""),
 #                dpi = 600, width = 4.4, height = 3, units = "in")
  clr <- c("Naive" = "#FFFFFF", "KKGK3" = "#b1b1b1", "KKGK4" = "#b1b1b1")  
  print(ggplot() +
        geom_col(data = bioMeanNorm, aes(x = mainCondition, y = mean),  position = position_dodge(), width = 0.5) +
        geom_point(data = percWramp.All.Norm %>% filter(mainCondition != "Naive"),
                   aes(x = mainCondition, y = perc, color = Experiment), 
                   position = position_jitterdodge(dodge.width = .3, jitter.width = 0.1, jitter.height = 0),
                  size = 2) +
        geom_errorbar(data = bioMeanNorm %>% filter(mainCondition != "Naive"), aes(x = mainCondition, ymin = mean-sd, ymax = mean+sd),
                      position = position_dodge(width = .5), 
                      width = 0.25,
                      alpha = 0.5) +
        geom_hline(yintercept = 1, linetype = "dashed") +
        theme_classic() +
        ylab("Polarized Cells \nNormalized to Naive") +
        ggtitle(title) +
        ylim(0,1) +
        theme(text = element_text(size = 14)))
 
# ggsave(paste(dirPath, "Output/Test/percPolarized_Norm_Colored", title, ".svg", sep = ""),
#                dpi = 600, width = 4.4, height = 3, units = "in")
  
   print(ggplot() +
        geom_col(data = bioMeanNorm, aes(x = mainCondition, y = mean, fill = mainCondition), 
                 position = position_dodge(), width = 0.6, color = "black") +
        geom_point(data = percWramp.All.Norm %>% filter(mainCondition != "Naive"),
                   aes(x = mainCondition, y = perc, fill = Experiment), 
                   position = position_jitterdodge(dodge.width = 0.3, jitter.width = 0.1, jitter.height = 0),
                  size = 1.5) +
        geom_errorbar(data = bioMeanNorm %>% filter(mainCondition != "Naive"), aes(x = mainCondition, ymin = mean-sd, ymax = mean+sd),
                      position = position_dodge(width = .6), 
                      width = 0.4,
                      alpha = 0.6,
                      size = 1) +
        geom_hline(yintercept = 1, linetype = "dashed") +
        theme_classic() +
        ylab("Polarized Cells \nNormalized to Naive") +
        ggtitle(title) +
        ylim(0,1) +
        scale_fill_manual(values = clr) +
        theme(text = element_text(size = 14),
              legend.position = "none"))
    
 # ggsave(paste(dirPath, "Output/Test/percPolarized_Norm_", title, ".svg", sep = ""),
 #               dpi = 600,  width = 2.5, height = 3, units = "in")

  percT <- percWramp.All.Norm %>% filter(classification=="OneEnd")
  
  ## Check normality (assuming unequal variances because all controls == 1)
  print(qqnorm(percT$perc[percT$mainCondition == "KKGK3"]))
  print(qqnorm(percT$perc[percT$mainCondition == "KKGK4"]))
  
  print(shapiro.test(percT$perc[percT$mainCondition == "KKGK3"]))
  print(shapiro.test(percT$perc[percT$mainCondition == "KKGK4"]))
  
  print("two-tailed t")
  print(pairwise.t.test(percT$perc, percT$mainCondition, pool.sd = F, p.adjust.method = "none")) # pool.sd = F for Welch's t-test
  
  print("two-tailed t - Holm-bonferroni")
  print(pairwise.t.test(percT$perc, percT$mainCondition, pool.sd = F, p.adjust.method = "holm"))
}
```

Calculate and save figures and .csv files for the proportion of cells with polarized MCAM.
```{r}
plotPolarSave(metricsClean.Classified.MCAM.Final, "comboGbmExtraTwo_MCAM2", "MCAM-AllCells")
```

Polarized MSN
```{r}
plotPolarSave(metricsClean.Classified.MSN.Final, "comboGbmExtraTwo_MSN2", "MSN-AllCells")
```

Polarized EZR
```{r}
plotPolarSave(metricsClean.Classified.EZR.Final, "comboGbmExtraTwo_EZR2", "EZR-AllCells")
```

Polarized phospho-ERM
```{r}
plotPolarSave(metricsClean.Classified.pERM.Final, "comboGbmExtraTwo_pERM2", "pERM-AllCells")
```

Function to normalize a feature to the median value of the Naive condition for each experiment (biological replicate). This is intended to account for differences in the IF signal between sample preps that are likely due to technical variation.
```{r}
medianNorm <- function(data, featureName, newFeatureName){
  metrics <- data %>%
    dplyr::rename(feature = featureName)
  
  # Calculate median of naive condition per experiment
  featureMedian <- metrics %>%
    filter(str_detect(Condition, "Naive")) %>% # Select control condition
    group_by(Experiment) %>%
    summarize(medianFeature = median(feature)) %>%
    ungroup()

  metricsNorm <- metrics %>%
    dplyr::mutate(featureNorm = ifelse(Experiment == featureMedian$Experiment[1], feature/featureMedian$medianFeature[1],
                                       ifelse(Experiment == featureMedian$Experiment[2], feature/featureMedian$medianFeature[2],
                                              ifelse(Experiment == featureMedian$Experiment[3], feature/featureMedian$medianFeature[3],
                                                     ifelse(Experiment == featureMedian$Experiment[4], feature/featureMedian$medianFeature[4],
                                                            ifelse(Experiment == featureMedian$Experiment[5], feature/featureMedian$medianFeature[5], NA))))))
  
  if(any(is.na(metricsNorm$featureNorm))){
    print("Normalized feature has NA")
  }
  
  metricsNorm <- metricsNorm %>%
    dplyr::rename_with(function(x){x = newFeatureName}, matches("featureNorm")) %>%
    dplyr::rename_with(function(x){x = featureName}, matches("feature"))
  
  return(metricsNorm)
}
```

Kernel density plot of normalized MCAM expression comparing polarized and nonpolarized cells for each cell line. Plotted for each replicate.
```{r}
# Normalized mean intensity per cell by dividing by the median of the control condition for each replicate
metricsMcam.Norm <- medianNorm(metricsClean.Classified.MCAM.Final, "meanIntensityCell_MCAM", "meanIntensityCell_MCAM_Norm") %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                      mainRep = str_remove(Replicate, "_Stain.*")) %>%
                      dplyr::mutate(mainCondition = factor(mainCondition, levels = c("KKGK4", "KKGK3", "Naive"))) # Reversed the order to change the order lines are added to plot

# Check normalization
identical(metricsMcam.Norm$meanIntensityCell_MCAM, metricsClean.Classified.MCAM.Final$meanIntensityCell_MCAM)

metricsMcam.Norm %>% 
  filter(str_detect(Condition, "Naive")) %>%
  group_by(Experiment) %>%
  summarize(median(meanIntensityCell_MCAM_Norm)) %>%
  ungroup() # Should be equal to 1 for each experiment

# No changes to original metrics
identical(metricsMcam.Norm %>% dplyr::select(-meanIntensityCell_MCAM_Norm, -mainCondition, -mainRep),
          metricsClean.Classified.MCAM.Final)  

# Density plots for each biological replicate
reps <- unique(metricsClean.Classified.MCAM.Final$Experiment)
clr2 = c("Naive" = "#737373", "KKGK3" = "#ff8d00", "KKGK4" = "#3cb300")

for(val in 1:5){
  print(ggplot(metricsMcam.Norm %>% 
                 filter(Experiment == reps[val]) %>%
         dplyr::mutate(WRAMP = ifelse(comboGbmExtraTwo_MCAM2 == "OneEnd", "OneEnd", "None")), aes(x = meanIntensityCell_MCAM_Norm, color = mainCondition, linetype = WRAMP)) + geom_density(linewidth = 1.2) + theme_classic() + ggtitle(reps[val]) + 
          xlab("Normalized Mean Intensity (A.U.)") + 
          ylab("Density") + theme(text = element_text(size = 22)) +
  scale_color_manual(values = clr2) +
    scale_linetype_manual(values = c("OneEnd" = "dashed", "None" = "solid")))
  # ggsave(paste(dirPath, "Output/Test/density_meanIntensityCell_MCAM_", reps[val], ".svg", sep = ""),
  #              dpi = 600, width =7, height = 4, units = "in")
  
  print(ggplot(metricsMcam.Norm %>% 
                 filter(Experiment == reps[val]) %>%
         dplyr::mutate(WRAMP = ifelse(comboGbmExtraTwo_MCAM2 == "OneEnd", "OneEnd", "None")), aes(x = meanIntensityCell_MCAM_Norm, color = mainCondition, linetype = WRAMP)) + geom_density(linewidth = 1.2) + theme_classic() + ggtitle(reps[val]) + 
          xlab("Normalized Mean Intensity (A.U.)") + 
          ylab("Density") + theme(text = element_text(size = 22)) + theme(text = element_text(size = 22)) +
  scale_color_manual(values = clr2) +
    scale_linetype_manual(values = c("OneEnd" = "dashed", "None" = "solid")) +
  coord_cartesian(xlim =c(0,3)))
  # ggsave(paste(dirPath, "Output/Test/density_meanIntensityCell_MCAM_Zoom", reps[val], ".svg", sep = ""),
  #              dpi = 600, width = 7, height = 4, units = "in")
}

# Number of cells excluded by trimming x-axis to the range of [0,3]
excluded <- nrow(metricsMcam.Norm %>% 
                   filter(Experiment == reps[4]) %>%
                   filter(meanIntensityCell_MCAM_Norm > 3))
# Number of cells included in plot
included <- nrow(metricsMcam.Norm %>% 
                   filter(Experiment == reps[4]) %>%
                   filter(meanIntensityCell_MCAM_Norm <= 3))
excluded
included
(included + excluded) == nrow(metricsClean.Classified.MCAM.Final %>% filter(Experiment == "20220921_Exp3"))
excluded/(included + excluded)*100

# Sample size for experiment 3 (representative replicate):
metricsMcam.Norm %>%
  filter(Experiment == reps[4]) %>%
  dplyr::mutate(WRAMP = ifelse(comboGbmExtraTwo_MCAM2 == "OneEnd", "OneEnd", "None")) %>%
  group_by(mainCondition, WRAMP) %>% count() %>% ungroup()

metricsMcam.Norm %>%
  filter(Experiment == reps[4]) %>%
  dplyr::mutate(zoom = ifelse(meanIntensityCell_MCAM_Norm <= 3, "In", "Out")) %>%
  group_by(mainCondition, zoom) %>% count() %>% ungroup()
```

Bin by intensity and plot percent of polarized cells:
```{r}
bins <- seq(0,10,length.out=101)
metricsMcam.Norm.Binned <- metricsMcam.Norm
for(val in 1:100){
  if(val == 1){
    metricsMcam.Norm.Binned <- metricsMcam.Norm.Binned %>%
      dplyr::mutate(binTemp = 11) %>%
      dplyr::mutate(bin = ifelse(meanIntensityCell_MCAM_Norm > bins[val] & meanIntensityCell_MCAM_Norm <= bins[val+1], bins[val+1], binTemp))
  }else{
    metricsMcam.Norm.Binned <- metricsMcam.Norm.Binned %>%
      dplyr::mutate(bin = ifelse(meanIntensityCell_MCAM_Norm > bins[val] & meanIntensityCell_MCAM_Norm <= bins[val+1], bins[val+1], bin))
  }
}

# write_csv(metricsMcam.Norm.Binned, paste(dirPath, "Output/Test/binnedData.csv", sep = ""))
metricsMcam.Norm.Binned %>% count(bin)
percWramp.Test.Rep <- metricsMcam.Norm.Binned %>%
    dplyr::rename(classification = comboGbmExtraTwo_MCAM2) %>%
    dplyr::mutate_at("classification", function(x){x = as.character(x)
                             x = ifelse(x == "BothEnds", "None", x)
                             x = factor(x, levels = c("OneEnd", "None"))}) %>%
    dplyr::select(Experiment, mainCondition, mainRep, bin, classification) %>%
    group_by(Experiment, mainCondition, mainRep, bin) %>%
      count(classification) %>%
    dplyr::mutate(perc = n/sum(n)*100, nTot = sum(n)) %>%
    ungroup() %>%
  filter(classification == "OneEnd") %>%
  filter(nTot > 50) # Only plotting replicates with at least 50 cells in the bin


goodReps <- metricsMcam.Norm.Binned %>% 
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                    mainRep = str_remove(Replicate, "_Stain.*")) %>%
  group_by(mainRep, bin) %>% count() %>%
  ungroup() %>%
  unite("mainRep_bin", mainRep:bin) %>%
  filter(n > 50)

# Plot all replicates, where points for different biological replicates have a unique shape
ggplot(percWramp.Test.Rep %>% filter(Experiment != "20220907_Pilot"), aes(x = bin, y = perc, shape = Experiment, color = mainCondition, group = mainRep)) + 
  geom_line(linewidth = 1) +
  geom_point(size = 2) +
  #geom_col(position = position_dodge(width = 0.5, preserve="single")) +
  #geom_errorbar(aes(ymin = meanBio - sdBio, ymax = meanBio + sdBio), position = position_dodge(width = 0.5, preserve = "single")) +
  theme_classic() + ylim(0, 80) +
  scale_x_continuous(breaks = seq(0,1.8, length.out = 19)) +
  xlab("Mean MCAM Intensity (0.1 width bin)") + 
  ggtitle(">50 cells per bin") + 
  theme(axis.text.y = element_text(size = 18),
        axis.title.x = element_text(size = 18),
        axis.title = element_text(size = 18),
        axis.text.x = element_text(angle = 90, hjust = 1, size = 15)) +
scale_color_manual(values = clr2)# + facet_grid(rows= vars(Experiment))
# ggsave(paste(dirPath, "Output/Test/meanIntensity_SmallBin_MoreThan50_Line.svg", sep = ""),
#                 dpi = 600, width = 6.8, height = 3.5, units = "in")


# Normalize each replicate to the % polarized across all cells for the Naive condition in that replicate
percWramp.All.Norm.Naive <- read.csv(paste(dirPath, "Input/percPolarized_MCAM-AllCells.csv", sep = "")) %>% filter(mainCondition == "Naive")

normBinned <- percWramp.Test.Rep %>%
  dplyr::mutate(percNorm = 
                  ifelse(Experiment == reps[1], perc/percWramp.All.Norm.Naive$perc[percWramp.All.Norm.Naive$Experiment == reps[1]],
                   ifelse(Experiment == reps[2], perc/percWramp.All.Norm.Naive$perc[percWramp.All.Norm.Naive$Experiment == reps[2]],
                   ifelse(Experiment == reps[3], perc/percWramp.All.Norm.Naive$perc[percWramp.All.Norm.Naive$Experiment == reps[3]], 
                   ifelse(Experiment == reps[4], perc/percWramp.All.Norm.Naive$perc[percWramp.All.Norm.Naive$Experiment == reps[4]],
                   ifelse(Experiment == reps[5], perc/percWramp.All.Norm.Naive$perc[percWramp.All.Norm.Naive$Experiment == reps[5]], NA))))))
  
ggplot(normBinned %>% filter(Experiment != "20220907_Pilot"), aes(x = bin, y = percNorm, color = mainCondition, group = mainRep)) + 
  geom_line(linewidth = 1) +
  geom_point(size = 2) +
  #geom_col(position = position_dodge(width = 0.5, preserve="single")) +
  #geom_errorbar(aes(ymin = meanBio - sdBio, ymax = meanBio + sdBio), position = position_dodge(width = 0.5, preserve = "single")) +
  theme_classic() + 
  scale_x_continuous(breaks = seq(0,1.8, length.out = 19)) +
  scale_y_continuous(breaks = seq(0,1.4, length.out = 8)) +
  xlab("Mean MCAM Intensity (0.1 Width Bin)") + 
  ggtitle(">50 cells per bin") + 
  theme(axis.text.y = element_text(size = 18),
        axis.title.x = element_text(size = 18),
        axis.title = element_text(size = 18),
        axis.text.x = element_text(angle = 90, hjust = 1, size = 15)) +
  scale_color_manual(values = clr2)
# ggsave(paste(dirPath, "Output/Test/meanIntensity_SmallBin_MoreThan50_Line_Norm.svg", sep = ""),
#                 dpi = 600, width = 6.8, height = 3.5, units = "in")

normBinned %>% filter(Experiment != "20220907_Pilot") %>% group_by(mainCondition) %>% summarize(sum(nTot))
```

Estimate co-polarization based on ML classification of MCAM and ERM channels:
```{r}
combinedClassifications <- rbind(metricsClean.Classified.MSN.Final %>%
                                   dplyr::rename(comboGbmExtraTwo_Other2 = comboGbmExtraTwo_MSN2) %>%
                                   merge(metricsClean.Classified.MCAM.Final %>% dplyr::select(Object, comboGbmExtraTwo_MCAM2), by = "Object"),
                                 metricsClean.Classified.EZR.Final %>%
                                   dplyr::rename(comboGbmExtraTwo_Other2 = comboGbmExtraTwo_EZR2) %>%
                                   merge(metricsClean.Classified.MCAM.Final %>% dplyr::select(Object, comboGbmExtraTwo_MCAM2), by = "Object"),
                                 metricsClean.Classified.pERM.Final %>%
                                   dplyr::rename(comboGbmExtraTwo_Other2 = comboGbmExtraTwo_pERM2) %>%
                                   merge(metricsClean.Classified.MCAM.Final %>% dplyr::select(Object, comboGbmExtraTwo_MCAM2), by = "Object")) %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                    mainRep = str_remove(Replicate, "_Stain.*")) %>%
                    dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4")))

nrow(combinedClassifications) == nrow(metricsClean.Classified.MCAM.Final %>% dplyr::filter(!str_detect(Condition, "RDX")))
setdiff(combinedClassifications$Object, metricsClean.Classified.MCAM.Final$Object[!str_detect(metricsClean.Classified.MCAM.Final$Condition, "RDX")])

eulerClass <- combinedClassifications %>% 
  dplyr::filter(str_detect(Condition, "Naive")) %>%
  dplyr::mutate(comboGbmExtraTwo_MCAM2 = as.character(comboGbmExtraTwo_MCAM2),
                comboGbmExtraTwo_Other2 = as.character(comboGbmExtraTwo_Other2)) %>%
  dplyr::mutate(polarMcam = ifelse(comboGbmExtraTwo_MCAM2 == "BothEnds", "None", comboGbmExtraTwo_MCAM2),
                polarOther = ifelse(comboGbmExtraTwo_Other2 == "BothEnds", "None", comboGbmExtraTwo_Other2)) %>% 
  group_by(Condition, polarMcam) %>%
  count(polarOther) %>% ungroup() %>%
  dplyr::mutate(eulerCombination = ifelse(polarOther))

eulerOverlap <- eulerClass %>%
  dplyr::filter(polarOther == "OneEnd", polarMcam == "OneEnd")
eulerTotals <- unique(eulerClass %>%
  dplyr::mutate(totCountsMcam = ifelse(polarMcam == "None", 0, n),
                totCountsOther = ifelse(polarOther == "None", 0, n)) %>%
  group_by(Condition) %>%
  dplyr::mutate(totMcam = sum(totCountsMcam), totOther = sum(totCountsOther)) %>%
  ungroup() %>%
  dplyr::select(Condition, totMcam, totOther))

# Venn diagrams
# svg(paste(dirPath, "Output/Test/EulerMSN.svg", sep = ""), width = 2, height = .85, pointsize = 20)
plot(venn(c("MCAM" = eulerTotals$totMcam[str_detect(eulerTotals$Condition, "MSN")] - eulerOverlap$n[str_detect(eulerOverlap$Condition, "MSN")], 
        "MSN" = eulerTotals$totOther[str_detect(eulerTotals$Condition, "MSN")] - eulerOverlap$n[str_detect(eulerOverlap$Condition, "MSN")],
      "MCAM&MSN" = eulerOverlap$n[str_detect(eulerOverlap$Condition, "MSN")])))
# dev.off()

# svg(paste(dirPath, "Output/Test/EulerEZR.svg", sep = ""), width = 2, height = .85, pointsize = 20)
plot(venn(c("MCAM" = eulerTotals$totMcam[str_detect(eulerTotals$Condition, "EZR")] - eulerOverlap$n[str_detect(eulerOverlap$Condition, "EZR")], 
        "EZR" = eulerTotals$totOther[str_detect(eulerTotals$Condition, "EZR")] - eulerOverlap$n[str_detect(eulerOverlap$Condition, "EZR")],
      "MCAM&EZR" = eulerOverlap$n[str_detect(eulerOverlap$Condition, "EZR")])))
# dev.off()

# svg(paste(dirPath, "Output/Test/EulerpERM.svg", sep = ""), width = 2, height = .85, pointsize = 20)
plot(venn(c("MCAM" = eulerTotals$totMcam[str_detect(eulerTotals$Condition, "pERM")] - eulerOverlap$n[str_detect(eulerOverlap$Condition, "pERM")], 
        "pERM" = eulerTotals$totOther[str_detect(eulerTotals$Condition, "pERM")] - eulerOverlap$n[str_detect(eulerOverlap$Condition, "pERM")],
      "MCAM&pERM" = eulerOverlap$n[str_detect(eulerOverlap$Condition, "pERM")])))
# dev.off()
```

Copy cells with a "OneEnd" classification into a new folder, randomly shuffle, and blind them for manual evaluation of co-polarization:
```{r}
# Find cells with a "OneEnd" ML classification for MCAM or ERM proteins:
oneEndMcam <- dplyr::filter(metricsClean.Classified.MCAM.Final, comboGbmExtraTwo_MCAM2 == "OneEnd") %>% dplyr::select(Object)
oneEndMsn <- dplyr::filter(metricsClean.Classified.MSN.Final, comboGbmExtraTwo_MSN2 == "OneEnd") %>% dplyr::select(Object)
oneEndEzr <- dplyr::filter(metricsClean.Classified.EZR.Final, comboGbmExtraTwo_EZR2 == "OneEnd") %>% dplyr::select(Object)
oneEndPerm <- dplyr::filter(metricsClean.Classified.pERM.Final, comboGbmExtraTwo_pERM2 == "OneEnd") %>% dplyr::select(Object)
oneEndRdx <- dplyr::filter(metricsClean.Classified.RDX.Final, comboGbmExtraTwo_RDX2 == "OneEnd") %>% dplyr::select(Object)

allOneEnd <- union(union(union(union(oneEndMcam, oneEndMsn), oneEndEzr), oneEndPerm), oneEndRdx)

# Remove cells that have already been manually evaluated to form the training set
oneEndRemaining <- allOneEnd %>%
  dplyr::filter(!Object %in% manualTrainUpdated$Object[manualTrainUpdated$ManualScoreMcam == "OneEnd"])
mcamOneEndRemaining <- oneEndMcam %>%
  dplyr::filter(!Object %in% manualTrainUpdated$Object[manualTrainUpdated$ManualScoreMcam == "OneEnd"])

# # Shuffle cells
# nCells <- length(oneEndRemaining$Object)
# set.seed(123)
# fileNameV1 <- paste(gsub(".nd2", "_Img_Cell", oneEndRemaining$Object)[sample(nCells, nCells, replace = F)], "_80thPctlNoClose.png", sep = "")
# fileNameV2 <- gsub("_80thPctlNoClose.png", "_Img_Cell_80thPctlNoClose.png", gsub("_Img_Cell", "", fileNameV1))
# 
# renameMatrix <- data.frame(newNum = 1:(nCells), imgNameV1 = fileNameV1, imgNameV2 = fileNameV2) %>%
#   dplyr::mutate(newNameImg = paste("80thPctlNoClose_c", as.character(newNum), "_Img.png", sep = ""),
#          newNameFig = paste("80thPctlNoClose_c", as.character(newNum), "_Fig.png", sep = ""),
#          figNameV1 = paste("Bg_", str_replace(imgNameV1, "Img", "Figure"), sep = ""),
#          figNameV2 = str_replace(imgNameV2, "Img", "Figure")) %>%
#    dplyr::mutate(pathNameImgV1 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/", imgNameV1, sep = ""),
#           pathNameImgV2 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/", imgNameV2, sep = ""),
#           pathNameFigV1 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/", figNameV1, sep = ""),
#           pathNameFigV2 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/", figNameV2, sep = "")) %>%
#   dplyr::mutate(toPathNameImgV1 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/CopolarRemaining/", imgNameV1, sep = ""),
#           toPathNameImgV2 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/CopolarRemaining/", imgNameV2, sep = ""),
#           toPathNameFigV1 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/CopolarRemaining/", figNameV1, sep = ""),
#           toPathNameFigV2 = paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/CopolarRemaining/", figNameV2, sep = ""))
# 
# file.copy(from = renameMatrix$pathNameImgV1, to = renameMatrix$toPathNameImgV1)
# file.copy(from = renameMatrix$pathNameImgV2, to = renameMatrix$toPathNameImgV2)
# file.copy(from = renameMatrix$pathNameFigV1, to = renameMatrix$toPathNameFigV1)
# file.copy(from = renameMatrix$pathNameFigV2, to = renameMatrix$toPathNameFigV2)
# 
# setwd(paste(dirPath, "MatlabAnalysis/WrampMetrics/Output/Figures/CopolarRemaining/", sep = ""))
# write.csv(renameMatrix, "Blinding_TrainingSetCopolarRemaining_20221227.csv")
# file.rename(renameMatrix$imgNameV1, renameMatrix$newNameImg)
# file.rename(renameMatrix$imgNameV2, renameMatrix$newNameImg)
# file.rename(renameMatrix$figNameV1, renameMatrix$newNameFig)
# file.rename(renameMatrix$figNameV2, renameMatrix$newNameFig)
```


Finalized co-polarization data for cells classified as having polarized MCAM (did not fully evaluate co-polarization manually for cells which only had a "OneEnd" classification for one of the ERM proteins):
```{r}
copolarMcam <- read.csv(paste(dirPath, "Input/copolarMcam_Stringent_20230305.csv", sep = "")) %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                    mainRep = str_remove(Replicate, "_Stain.*")) %>%
                    dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4")))
str(copolarMcam)
```

Differences in misclassifications:
```{r}
combinedClassifications.Labeled <- combinedClassifications %>% 
  dplyr::mutate(stain = str_remove(Condition, ".*Stain")) %>%
  dplyr::select(stain, Object, comboGbmExtraTwo_MCAM2, comboGbmExtraTwo_Other2, mainCondition) %>%
  merge(manualTrainUpdated, by="Object") %>% # No RDX stained cells
  mutate_at(vars(contains("ManualScore")|contains("combo")), function(x){x = as.character(x)
                             x = ifelse(x == "BothEnds", "None", x)
                             x = factor(x, levels = c("OneEnd", "None"))})


combinedClassifications.Labeled %>% 
  filter(mainCondition == "Naive") %>%
  filter(!is.na(ManualScoreMcam)) %>%
  group_by(stain, ManualScoreMcam, comboGbmExtraTwo_MCAM2, ManualScoreOther) %>% count(comboGbmExtraTwo_Other2) %>% ungroup() %>%
  group_by(stain, ManualScoreMcam) %>%
  dplyr::mutate(perc = n/sum(n), nTot = sum(n)) %>%
  ungroup() 

combinedClassifications.Labeled %>% 
  filter(mainCondition == "Naive") %>%
  filter(!is.na(ManualScoreMcam)) %>%
  group_by(stain, ManualScoreMcam) %>% count(ManualScoreOther) %>% ungroup() %>%
  group_by(stain, ManualScoreMcam) %>%
  dplyr::mutate(perc = n/sum(n), nTot = sum(n)) %>%
  ungroup() 
```


"Label" the copolarization data, where 1 = copolarized (meaning both proteins had polarized protein on the same side of the cell).
```{r}
# There are two cases where ManualScoreFactin == "BothEnds", but SameSideFactin == "No". It is that way in the raw file. After looking at the images, I think the score should have been "OneEnd" (on the opposite end of the cell). However, these cells will not be counted as copolar in the the data.frame below.
dplyr::filter(copolarMcam, ManualScoreFactin == "BothEnds", !is.na(SameSideFactin))
dplyr::filter(copolarMcam, ManualScoreFactin == "None", !is.na(SameSideFactin)) # 3 cells, none copolarized and will be removed
# Note that cells from the training sets have duplicate blinding names, so they must be referenced by Object.

copolarMcamLabeled <- copolarMcam %>%
  dplyr::filter(is.na(Segmentation)) %>%
  dplyr::filter(ManualScoreMcam != "None") %>% # Note: this will not work if there are NAs in ManualScoreMcam
  dplyr::mutate(copolarOther = ifelse(ManualScoreOther!="None" & is.na(SameSideOther), 1, 0),
                copolarFactin = ifelse(ManualScoreFactin!="None" & is.na(SameSideFactin), 1, 0),
                copolarTriple = ifelse((copolarOther == 1 & copolarFactin == 1), 1, 0))

# Check removal of "None" cells
unique(copolarMcamLabeled$ManualScoreMcam)
# Check assignment of copolar values
copolarMcamLabeled %>% group_by(ManualScoreOther, SameSideOther) %>% count(copolarOther) %>% ungroup()
copolarMcamLabeled %>% group_by(ManualScoreFactin, SameSideFactin) %>% count(copolarFactin) %>% ungroup()
copolarMcamLabeled %>% group_by(ManualScoreOther, ManualScoreFactin, SameSideOther, SameSideFactin) %>% count(copolarTriple) %>% ungroup()
copolarMcamLabeled %>% group_by(copolarOther, copolarFactin) %>% count(copolarTriple) %>% ungroup()
```

Calculate percent co-polarized (relative to MCAM). The percent of cells with polarized MCAM which also have polarized ___.
```{r}
copolarizationPerc <- copolarMcamLabeled %>%
  dplyr::mutate(stain = str_remove(Condition, ".*Stain")) %>%
  dplyr::select(Experiment, Object, copolarOther, copolarFactin, copolarTriple, Condition, Replicate, mainRep, stain) %>%
  gather(key = "polarizedProtein", value = "class", -Object, -Condition, -Replicate, -stain, -mainRep, -Experiment) %>%
  dplyr::mutate(polarizedProteinMain = polarizedProtein,
                polarizedProtein = str_replace(polarizedProtein, "Other", str_remove(Condition, ".*Stain"))) %>%
  dplyr::mutate(polarizedProtein = ifelse(str_detect(polarizedProtein, "Triple"), paste(polarizedProtein, str_remove(Condition, ".*Stain"), sep = ""), polarizedProtein)) %>%
  group_by(Experiment, Condition, mainRep, Replicate, polarizedProteinMain, polarizedProtein, stain) %>%
  count(class) %>%
  dplyr::mutate(perc = n/sum(n)*100, nTot = sum(n)) %>% 
  ungroup() %>%
  dplyr::mutate(polarizedProteinMain = factor(polarizedProteinMain, levels = c("copolarOther", "copolarFactin", "copolarTriple"))) %>%
  dplyr::mutate(stain = factor(stain, levels = c("MCAM-MSN-Factin", "MCAM-EZR-Factin", "MCAM-RDX-Factin", "MCAM-pERM-Factin")))

copolarizationPerc %>% group_by(Replicate, polarizedProtein) %>% summarize(sum(perc)) %>% ungroup()
copolarizationPerc %>% filter(class == 1) %>% arrange(Replicate)

copolarBioMeans <- copolarizationPerc %>%
  dplyr::filter(class == 1) %>%
  group_by(Condition, stain, polarizedProtein, polarizedProteinMain) %>%
  summarize(meanCopolar = mean(perc),
            sdCopolar = sd(perc)) %>%
  ungroup()

# Sample size per condition
copolarizationPerc %>% 
  dplyr::filter(class == 1, polarizedProteinMain == "copolarOther") %>% group_by(Condition) %>% summarize(sum(nTot)) %>% ungroup()
```

Figure for Naive cells only:
```{r}
stainClr <- c("copolarOther" = "#D100D1", "copolarFactin" = "#FFBF00", "copolarTriple" = "#00D1D1")
ggplot() +
  geom_col(data = copolarBioMeans %>%
             dplyr::filter(str_detect(Condition, "Naive")),
           aes(x = stain, y = meanCopolar, fill = polarizedProteinMain), position = position_dodge(.7), width = 0.7) +
  geom_point(data = copolarizationPerc %>% dplyr::filter(class == 1) %>%
              dplyr::filter(str_detect(Condition, "Naive")),
              aes(x = stain, y = perc, fill = Experiment, group = polarizedProteinMain),
              position = position_jitterdodge(dodge.width = .7, jitter.width = 0.12, jitter.height = 0),
              size = 1.2, alpha =.6) +
  geom_errorbar(data = copolarBioMeans %>%
                  dplyr::filter(str_detect(Condition, "Naive")), 
                aes(x = stain, ymin = meanCopolar-sdCopolar, ymax = meanCopolar+sdCopolar, group = polarizedProteinMain), 
                position = position_dodge(width = .7), 
                width = 0.35,
                alpha = 1,
                linewidth = .7) +
  theme_classic() + 
  ylim(0,100) +
  scale_fill_manual(values = stainClr) +
  ylab("Copolarized Cells (%) \nRelative to MCAM") +
  xlab("") +
  theme(axis.title.y = element_text(size = 16),
        axis.text.y = element_text(size = 14),
        axis.text.x = element_text(size = 14, angle = 45, hjust = 1)) +
  scale_shape_discrete("Replicate")
# ggsave(paste(dirPath, "Output/Test/copolarMcam_PercentCopolarizedManual_Naive.svg", sep = ""),
#        dpi = 600, width = 5.5, height = 3.7, units = "in")

copolarTnaive <- copolarizationPerc %>% filter(class == 1, str_detect(Condition, "Naive")) %>%
  dplyr::filter(polarizedProteinMain != "copolarTriple") %>%
  dplyr::mutate(kPolar = paste(polarizedProteinMain, stain, sep = "_"))

# Kruskal-Wallace test
kruskal.test(perc ~ kPolar, 
             data = copolarTnaive %>% dplyr::mutate(kPolar = factor(kPolar)))

d <- dunnTest(perc ~ kPolar, 
             data = copolarTnaive %>% dplyr::mutate(kPolar = factor(kPolar)))
dunnDf <- d[["res"]]
dunnComparisons <- c("msnVezr" = "copolarOther_MCAM-EZR-Factin - copolarOther_MCAM-MSN-Factin",
                     "permVezr" = "copolarOther_MCAM-EZR-Factin - copolarOther_MCAM-pERM-Factin",
                     "rdxVezr" = "copolarOther_MCAM-EZR-Factin - copolarOther_MCAM-RDX-Factin",
                     "permVmsn" = "copolarOther_MCAM-MSN-Factin - copolarOther_MCAM-pERM-Factin",
                     "rdxVmsn" = "copolarOther_MCAM-MSN-Factin - copolarOther_MCAM-RDX-Factin",
                     "rdxVperm" = "copolarOther_MCAM-pERM-Factin - copolarOther_MCAM-RDX-Factin",
                     "msnVfactin" = "copolarFactin_MCAM-MSN-Factin - copolarOther_MCAM-MSN-Factin",
                     "ezrVfactin" = "copolarFactin_MCAM-EZR-Factin - copolarOther_MCAM-EZR-Factin",
                     "permVfactin" = "copolarFactin_MCAM-pERM-Factin - copolarOther_MCAM-pERM-Factin",
                     "rdxVfactin" = "copolarFactin_MCAM-RDX-Factin - copolarOther_MCAM-RDX-Factin")

dunnValues <- dunnDf %>% filter(Comparison %in% dunnComparisons)
print(dunnDf %>% filter(Comparison %in% dunnValues$Comparison[str_detect(dunnValues$Comparison, "copolarFactin")]))
p.adjust(dunnValues$P.unadj[str_detect(dunnValues$Comparison, "copolarFactin")], "holm")
dunnValues$Comparison[str_detect(dunnValues$Comparison, "copolarFactin")]
```

Plot for CRISPR clones and comparison to Naive (supplemental figure).
```{r}
# Note that nTot for CRISPR cells is very small... This will be supplemental
clr2 = c("Naive" = "#737373", "KKGK3" = "#ff8d00", "KKGK4" = "#3cb300")

# Percent copolarization of F-actin across all staining sets
copolarizationFactinPerc <- copolarMcamLabeled %>%
  dplyr::select(mainCondition, mainRep, copolarFactin) %>%
  group_by(mainCondition, mainRep) %>%
  count(copolarFactin) %>%
  dplyr::mutate(perc = n/sum(n)*100, nTot = sum(n)) %>%
  ungroup() %>%
  dplyr::rename(class = copolarFactin) %>%
  dplyr::mutate(polarizedProtein = "copolarFactin",
                polarizedProteinMain = "copolarFactin",
                Replicate = mainRep,
                stain = "MCAM-Factin",
                Condition = mainCondition) %>%
    dplyr::select(-mainCondition) %>% 
  merge(unique(annotationCrispr %>% 
          dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                    mainRep = str_remove(Replicate, "_Stain.*")) %>%
                    dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4"))) %>%
          dplyr::select(Experiment, mainRep)), by = "mainRep")

copolarizationSupp <- rbind(copolarizationPerc %>%
    dplyr::filter(polarizedProteinMain != "copolarFactin", polarizedProteinMain != "copolarTriple") %>%
    dplyr::mutate(stain = str_remove(stain, "-Factin")), 
  copolarizationFactinPerc) %>%
    dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*")) %>%
    dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4"))) %>%
    dplyr::mutate(stain = factor(stain, levels = c("MCAM-MSN", "MCAM-EZR", "MCAM-RDX", "MCAM-pERM", "MCAM-Factin")))

copolarizationSuppMean <- copolarizationSupp %>%
  filter(class == 1) %>%
  group_by(mainCondition, Condition, stain, polarizedProtein, polarizedProteinMain) %>%
  summarize(meanCopolar = mean(perc), sdCopolar = sd(perc)) %>%
  ungroup()

ggplot() +
  geom_col(data = copolarizationSuppMean,
           aes(x = stain, y = meanCopolar, fill = mainCondition), position = position_dodge(.7), width = 0.7) +
  geom_point(data = copolarizationSupp %>% dplyr::filter(class == 1),
              aes(x = stain, y = perc, fill = Experiment, group = mainCondition),
              position = position_jitterdodge(dodge.width = .7, jitter.width = 0.12, jitter.height = 0),
              size = 1.2, alpha =.6) +
  geom_errorbar(data = copolarizationSuppMean, 
                aes(x = stain, ymin = meanCopolar-sdCopolar, ymax = meanCopolar+sdCopolar, group = mainCondition), 
                position = position_dodge(width = .7), 
                width = 0.35,
                alpha = 1,
                linewidth = .7) +
  theme_classic() + 
  ylim(0,100) +
  scale_fill_manual(values = clr2) +
  ylab("Copolarized Cells (%) \nRelative to MCAM") +
  xlab("") +
  theme(axis.title.y = element_text(size = 16),
        axis.text.y = element_text(size = 14),
        axis.text.x = element_text(size = 14, angle = 45, hjust = 1)) +
  scale_shape_discrete("Replicate")
# ggsave(paste(dirPath, "Output/Test/copolarMcam_PercentCopolarized_CrisprSupp.svg", sep = ""),
#        dpi = 600, width = 6.5, height = 3.7, units = "in")

copolarizationSupp %>% filter(class == 1, polarizedProteinMain == "copolarOther") %>% group_by(mainCondition, polarizedProtein) %>% summarize(sum(nTot)) %>% ungroup() # Same sample size as above

copolarizationSupp %>% filter(class == 1, polarizedProteinMain == "copolarFactin") %>% group_by(mainCondition, polarizedProtein) %>% summarize(sum(nTot)) %>% ungroup()

copolarTcrispr <- copolarizationSupp %>% filter(class == 1)
kruskal.test(perc ~ mainCondition, data = copolarTcrispr %>% filter(stain == "MCAM-MSN"))
kruskal.test(perc ~ mainCondition, data = copolarTcrispr %>% filter(stain == "MCAM-EZR"))
kruskal.test(perc ~ mainCondition, data = copolarTcrispr %>% filter(stain == "MCAM-pERM"))
kruskal.test(perc ~ mainCondition, data = copolarTcrispr %>% filter(stain == "MCAM-Factin"))
print(dunnTest(perc ~ mainCondition, data = copolarTcrispr %>% filter(stain == "MCAM-Factin")))
```

Plot colocalization measurements which compare the brighest object in the MCAM channel to the brightest object in the ERM channel.
```{r}
colocMetrics <- copolarMcamLabeled %>%
  dplyr::filter(!str_detect(Condition, "RDX"), !str_detect(Image, "RDX")) %>% # Off-target nuclear signal confounds segmentation of polarized area
  dplyr::filter(copolarOther == 1) %>%
  dplyr::mutate(WrongObject = ifelse(is.na(WrongObject), "No", WrongObject)) %>%
  dplyr::filter(!WrongObject == "Yes") %>%
  dplyr::filter(!str_detect(WrongObject, "Yes - Other")) %>%
  merge(metricsClean.Classified.MCAM.Final %>% dplyr::select(-all_of(colnames(annotationCrispr))), by = "Object") %>%
  dplyr::mutate(stain = str_remove(Condition, ".*Stain")) %>%
  dplyr::mutate(stain = factor(stain, levels = c("MCAM-MSN-Factin", "MCAM-EZR-Factin", "MCAM-pERM-Factin")))
unique(colocMetrics$stain)
colocMetricsNaive <- colocMetrics %>% dplyr::filter(mainCondition == "Naive")

# Figures
ggplot(colocMetricsNaive, aes(x = stain, y = mandersMainOtherBrightest1)) +
  geom_beeswarm(data = NULL, aes(x = stain, y = mandersMainOtherBrightest1, group = stain, color = Experiment),
           cex=.18, dodge.width = 0.7, alpha = .2, size = 2.5) + 
  geom_boxplot(data = NULL, aes(x = stain, y = mandersMainOtherBrightest1, fill = Experiment), width = 0.55, position = position_dodge(width = 0.7), outlier.shape = NA, alpha = 0,linewidth = 0.8) +
  theme_classic() +
  ylab("MCC1") +
  theme(legend.position = "none",
        text = element_text(size = 20)) +
  scale_fill_brewer(palette = "Dark2") +
  scale_color_brewer(palette = "Dark2")
# ggsave(paste(dirPath, "Output/Test/colocMCC1_V3.svg", sep = ""),
#        dpi = 600, width = 5.2, height = 4, units = "in")

ggplot(colocMetricsNaive, aes(x = stain, y = mandersMainOtherBrightest2)) +
  geom_beeswarm(data = NULL, aes(x = stain, y = mandersMainOtherBrightest2, group = stain, color = Experiment),
           cex=.45, dodge.width = 0.7, alpha = .2, size = 2.5) + 
  geom_boxplot(data = NULL, aes(x = stain, y = mandersMainOtherBrightest2, fill = Experiment), width = 0.55, position = position_dodge(width = 0.7), outlier.shape = NA, alpha = 0,linewidth = 0.8) +
  theme_classic() +
  ylab("MCC2") +
  theme(legend.position = "none",
        text = element_text(size = 20)) +
  scale_fill_brewer(palette = "Dark2") +
  scale_color_brewer(palette = "Dark2")
# ggsave(paste(dirPath, "Output/Test/colocMCC2_V3.svg", sep = ""),
#        dpi = 600, width = 5.2, height = 4, units = "in")

ggplot(colocMetricsNaive %>%
         dplyr::mutate(distNormed = distWeightedOther2Main/MaxFeretDiameter), aes(x = stain, y = distNormed)) + 
  geom_beeswarm(data = NULL, aes(x = stain, y = distNormed, group = stain, color = Experiment),
           cex=.32, dodge.width = 0.7, alpha = .2, size = 2.5) + 
  geom_hline(yintercept = 0, color = "gray45", linewidth = .8) +
  geom_hline(yintercept = 0.04, color = "gray45", linetype = "dashed", linewidth = .8) +
  geom_hline(yintercept = -0.04, color = "gray45", linetype = "dashed", linewidth = .8) +
  geom_boxplot(data = NULL, aes(x = stain, y = distNormed, fill = Experiment), width = 0.55, position = position_dodge(width = 0.7), outlier.shape = NA, alpha = 0,linewidth = .8) +
  # geom_point(data = colocMetricsMedian, aes(x = stain, y = medDist, fill = Experiment), 
  #            position=position_quasirandom(dodge.width = 0.2, groupOnX = T),
  #            size = 2.5, shape = 24, alpha = 0.9) +
  theme_classic() + ylim(-.5,.5) +
  ylab("Distance Between Centroids") +
  theme(legend.position = "none",
        text = element_text(size = 20)) +
  scale_fill_brewer(palette = "Dark2") +
  scale_color_brewer(palette = "Dark2")
# ggsave(paste(dirPath, "Output/Test/weightedDistance_V3.svg", sep = ""),
#        dpi = 600, width = 5.2, height = 4, units = "in")
```

Combine classified features for supplemental data file:
```{r}
suppTemp <- rbind(metricsClean.Classified.MSN.Final %>%
                                   dplyr::rename(comboGbmExtraTwo_Other2 = comboGbmExtraTwo_MSN2) %>%
                                   merge(metricsClean.Classified.MCAM.Final %>% dplyr::select(Object, comboGbmExtraTwo_MCAM2), by = "Object"),
                                 metricsClean.Classified.EZR.Final %>%
                                   dplyr::rename(comboGbmExtraTwo_Other2 = comboGbmExtraTwo_EZR2) %>%
                                   merge(metricsClean.Classified.MCAM.Final %>% dplyr::select(Object, comboGbmExtraTwo_MCAM2), by = "Object"),
                                 metricsClean.Classified.pERM.Final %>%
                                   dplyr::rename(comboGbmExtraTwo_Other2 = comboGbmExtraTwo_pERM2) %>%
                                   merge(metricsClean.Classified.MCAM.Final %>% dplyr::select(Object, comboGbmExtraTwo_MCAM2), by = "Object"),
                                metricsClean.Classified.RDX.Final %>%
                                  dplyr::rename(comboGbmExtraTwo_Other2 = comboGbmExtraTwo_RDX2) %>%
                                merge(metricsClean.Classified.MCAM.Final %>% dplyr::select(Object, comboGbmExtraTwo_MCAM2), by = "Object") %>%
                                dplyr::mutate(comboGbmExtraTwo_Other2 = NA)) %>%
  dplyr::mutate(mainCondition = str_remove(Condition, "_Stain.*"),
                    mainRep = str_remove(Replicate, "_Stain.*")) %>%
                    dplyr::mutate(mainCondition = factor(mainCondition, levels = c("Naive", "KKGK3", "KKGK4"))) %>%
  arrange(Object)

# Check
suppTemp %>% count(comboGbmExtraTwo_Other2)
suppTemp %>% filter(str_detect(Image, "RDX")) %>% count(comboGbmExtraTwo_Other2)
sum(duplicated(suppTemp$Object))
identical(suppTemp %>% dplyr::select(colnames(metricsClean.Classified.MCAM.Final)), metricsClean.Classified.MCAM.Final)

# Rearrange order of columns and merge with copolarization data
suppFeatures <- read.csv(paste(dirPath, "Input/SupplementalFeatures.csv", sep = ""))

supp <- suppTemp %>%
  dplyr::mutate(Stain = str_remove(Condition, ".*Stain")) %>%
  merge(copolarMcamLabeled %>% dplyr::select(Object, copolarOther, copolarFactin, copolarTriple), all.x = T, all.y = T, by = "Object") %>%
  merge(manualTrainUpdated %>% filter(is.na(Segmentation)) %>% dplyr::select(ManualScoreMcam, ManualScoreOther, Object), all.x = T, all.y = T, by = "Object") %>%
  dplyr::mutate(ColocalizationPlot = ifelse(Object %in% colocMetricsNaive$Object, "Yes", "No")) %>%
  dplyr::select(all_of(suppFeatures$Feature)) %>%
  dplyr::rename(MCAM_Classification = comboGbmExtraTwo_MCAM2,
                ERM_Classification = comboGbmExtraTwo_Other2) %>%
  arrange(Object)

# Check
supp %>% count(ColocalizationPlot)
supp %>% group_by(ManualScoreMcam) %>% count(ManualScoreOther) %>% ungroup()
manualTrainUpdated %>% group_by(ManualScoreMcam) %>% count(ManualScoreOther) %>% ungroup()

identical(supp %>% 
            dplyr::rename(comboGbmExtraTwo_MCAM2 = MCAM_Classification,
                          comboGbmExtraTwo_Other2 = ERM_Classification) %>%
            dplyr::select(any_of(colnames(metricsClean.Classified.MCAM.Final))), 
          metricsClean.Classified.MCAM.Final %>% dplyr::select(any_of(colnames(supp)), contains("comboGbm")) %>%
            dplyr::select(any_of(colnames(metricsClean.Classified.MCAM.Final))))
unique(supp$Stain)

write_csv(supp, paste(dirPath, "Output/SupplementalData_NaiveCrispr.csv", sep = ""))
```

Supplemental data of scaled features:
```{r}
suppScaled.MCAM <- metricsScaled.MCAM %>% dplyr::select(-Normalization) %>%
  arrange(Object)
identical(suppScaled.MCAM$Object, supp$Object)

suppScaled.Other <- rbind(metricsScaled.MSN, metricsScaled.EZR, metricsScaled.pERM) %>% dplyr::select(-Normalization) %>%
  arrange(Object)
(nrow(suppScaled.Other) + nrow(metricsScaled.RDX)) == nrow(suppScaled.MCAM)

setdiff(suppScaled.MCAM$Object[!str_detect(suppScaled.MCAM$Condition, "RDX")], suppScaled.Other$Object)
setdiff(suppScaled.Other$Object, suppScaled.MCAM$Object[!str_detect(suppScaled.MCAM$Condition, "RDX")])

write_csv(supp, paste(dirPath, "Output/SupplementalData_NaiveCrispr_Scaled.csv", sep = ""))
```

