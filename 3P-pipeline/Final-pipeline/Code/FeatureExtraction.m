%% Introduction

% This script contains the code to read in .nd2 images and previously
% generated .tif files containing masks and label images of segmentation.

% The brightest region in each cell is then segmented using a percentile
% threshold where the connected component above the threshold which
% contains the highest integrated intensity is selected (the "brightest
% object"). Features are then calculated for each cell based on the
% brightest object, which can be used to classify cells with polarized
% protein using machine learning or to quantify copolarization of proteins
% from multichannel images.

% Note that because this code was developed to identify cells with a
% polarized protein which marks the WRAMP structure in cells, "wramp" is
% used in the variable names to refer to the brightest object. 
%% Enter directory paths

clear 
close all

% Date this script was run on (for naming saved output)
dateRan = '20221211'; 

% Matlab version R2020a

% Path for bioformats toolbox
addpath 'C:\...\bfmatlab' 
% Path for my functions
addpath 'C:\...\CrisprClones\Analysis20221211\MatlabAnalysis\MatlabFunctions'

% Enter directory path(s) for images:
% Image directories:
imgDir1p = "C:\...\CrisprClones\ImageData\NikonWidefield\Pilot\20220907";
imgDir1 = "C:\...\CrisprClones\ImageData\NikonWidefield\Experiment1\20220915";
imgDir2 = "C:\...\CrisprClones\ImageData\NikonWidefield\Experiment2\20220923";
imgDir3 = "C:\...\CrisprClones\ImageData\NikonWidefield\Experiment3\20220926";
imgDir4 = "C:\...\CrisprClones\ImageData\NikonWidefield\Experiment4\20221007";
imgDir5 = "C:\...\CrisprClones\ImageData\NikonWidefield\Experiment4\20221010\pMLC";
imgDir6 = "C:\...\CrisprClones\ImageData\NikonWidefield\Experiment3\20220928\Radixin-CS";

imgDir = [imgDir1p imgDir1 imgDir2 imgDir3 imgDir4 imgDir5 imgDir6];

% Enter base directory for matlab analysis (contains existing folders with
% masks and segmentation):
% Base directory for analysis folders:
baseDir = 'C:\...\CrisprClones\Analysis20221211\MatlabAnalysis\';

% Option: use metadata file generated by mask.m script to identify channel index? 
% (Particularly useful if channels are not collected in the same order for all images.) 
% 1 means yes, 0 means no. If images were segmented using an alternative
% approach, enter option 0 and provide the channel index informtion
% manually.
useMeta = 1; 

% If useMeta == 1, assign these variables:
    % Metadata file created by mask.m script
    metaTable1 = readtable([baseDir, '\BeginAnnotationFilePilot.csv']);
    metaTable2 = readtable([baseDir, '\BeginAnnotationFileExp1to4.csv']);
    metaTableAll = vertcat(metaTable1, metaTable2);
    if length(metaTableAll.Image) ~= length(unique(metaTableAll.Image))
        warning('Duplicate entries in metadata file')
    end
    
    % Assign channels named in the metadata file to main, other (second 
    % channels), and third channel for analysis. The name must match the 
    % variable name in metaTableAll.

    % Note: The main channel determines profiles plotted in the
    % figure are oriented based on the wrampAngle for this channel and features
    % shared by all channels (e.g., cell area, major axis angle, etc.) are
    % calculated during the main channel loop.
    % If the main channel is not consistent throughout the experiment (for
    % example, if MCAM is labeled with a different secondary in some
    % conditions), you will need to code these variables within the analysis
    % loop).
    mainChName = 'FITC'; % Usually this channel should be the channel for MCAM staining.
    otherChName = 'TxRedCy5'; % Enter name for second channel here if only a two-channel image
    thirdChName = 'DAPI';

% If not using metadata to assign channel order, enter the channel index
% here:
% mainChannel = 1;
% otherChannel = 2; % If there is not a second channel, enter 0.
% thirdChannel = 3; % If there is not a third channel, enter 0.

% Specify whether all images contain only one channel (1 for true, 0 for
% false). (Or enter 1 if you only want to analyze main channel).
onlyOneChannel = 0;

% Specify whether all images contain only two channels(1 for true, 0 for
% false). (Or enter 1 if you only want to analyze "mainChannel" and
% "otherChannel").
onlyTwoChannels = 0;

% Assign names to use in saved feature file names 
% This name will also be used to title the images saved in the figure. If
% you don't want to use the same name in the figures or want to change the
% figure titles for different images (e.g., for different proteins imaged
% in the same channel), set the figName variables within the analysis loop.
mainSuffix = 'MCAM'; % Appended to datafile names for each channel
otherSuffix = 'Other'; 
thirdSuffix = 'Factin'; 

% Images to remove from analysis (images which are in the image directory but not intended to be part of quantitative analysis or images with bad segmentation)
notQuantifiedImg = ["20220907_KKGKclone4_MCAM488-120_MSN594-100_Ph405-150_60X_001"]; % Longer MCAM exposure than other images
notSegmentedImg = ["20220923_EricR23_MCAM488-100_EZR594-100_Ph405-150_60X_S2_007", "20220923_KKGK3_MCAM488-100_MSN594-100_Ph405-150_60X_S1_007", "20221007_EricR23_MCAM488-100_EZR594-100_Ph405-150_60X_S1_004", "20220923_KKGK4_MCAM488-100_EZR594-100_Ph405-150_60X_S1_001", "pMLC", "20220908", "20220915_KKGK-3_MCAM488-100_MSN594-100_Ph405-150_60X_S2_008"];

% Option: Save background subtraction masks? (1 means yes, 0 means no).
% Background subtraction masks are needed to run CellProfiler, but it's
% useful to set this to 0 to rerun the matlab parameters without
% overwriting the existing masks.
saveMaskBg = 1;

% Set percentile to be used as threshold to mask bright objects in cell
percentile = 80; % Option to run script using multiple intensity percentile cutoffs (e.g., percentile = [70 80 90])

% Create folders for output
cd(baseDir)
mkdir BackgroundSubtraction % Folder for saving masks for background subtraction to use in CellProfiler
mkdir WrampMetrics 
mkdir ImageTiffs 
cd([baseDir, '\WrampMetrics'])
mkdir Output % Folder for measured feature values
mkdir Output Figures % Folder for images/figures of each individual cell
%% Check image info
for i = 1:numel(imgDir)
    cd(imgDir(i))
    imgInfoTemp = dir('*.nd2*');
    imnamesTemp = string({imgInfoTemp.name});
    imnamesByDir(i).imnames = imnamesTemp;
    if i == 1
        imnames = imnamesTemp;
    else
        imnames = [imnames, imnamesTemp];
    end
end

% Remove bad images or images you don't want to quantify that are contained
% in the same directory.
if isempty(notQuantifiedImg) ~= 1
    imnames(contains(imnames, notQuantifiedImg)) = [];
end
if isempty(notSegmentedImg) ~= 1
    imnames(contains(imnames, notSegmentedImg)) = [];
end

% Load in segmentation (label matrix)
% Directory of segmentation images:
segDir = [baseDir, '\ManualSegmentation'];
cd(segDir)
segInfo = dir('*Segmented*');
segnamesTemp = string({segInfo.name});

% Raw mask info (for background subtraction)
% Directory of raw (uncorrected) masks:
maskDir = [baseDir, '\Masks'];
cd(maskDir)
overlayInfo = dir('*overlay*');
maskInfo = dir('*tif*');
maskInfo(contains(string({maskInfo.name}), string({overlayInfo.name}))) = [];
masknamesTemp = string({maskInfo.name});
if isempty(notQuantifiedImg) ~= 1
    masknamesTemp(contains(masknamesTemp, notQuantifiedImg)) = [];
end
if isempty(notSegmentedImg) ~= 1
    masknamesTemp(contains(masknamesTemp, notSegmentedImg)) = [];
end

% Makes sure order of masks and segmentation in the same order as image directory so
% that correct mask and segmentation is used for each image
for imnum = 1:length(imnames)
    maskIdx = find(matches(masknamesTemp, [char(extractBefore(imnames(imnum), '.nd2')), '.tif']));
    masknames(imnum) = masknamesTemp(maskIdx);
    segIdx = find(matches(segnamesTemp, ['Segmented_', char(extractBefore(imnames(imnum), '.nd2')), '.tif']));
    segnames(imnum) = segnamesTemp(segIdx);
end

% Check that mask name matches image name
matchNames(imnames, masknames, segnames)
if length(imnames) ~= length(masknames) || length(imnames) ~= length(segnames) || length(masknames) ~= length(segnames)
    warning('Name indexes are different lengths')
end 

%% Calculate WRAMP metrics
% Remove imclose from cellPrctile
for p = 1:length(percentile)
    imnumStart = 1;
    if imnumStart ~= 1
        warning('Image index (imnum) for first loop is not equal to one')
    end
    for imnum = imnumStart:length(imnames)
        clearvars -except imgInfo onlyOneChannel onlyTwoChannels saveMaskBg mainSuffix otherSuffix thirdSuffix useMeta metaTableAll otherChName mainChName thirdChName figNameMain figNameOther figNameThird imnames seg segInfo dateRan allStats allChStatsMain allChStatsThird allChStatsOther imnum allWrampEdgeDistanceStatsMain allWrampEdgeDistanceStatsThird allWrampEdgeDistanceStatsOther allCenter2WrampStatsMain allCenter2WrampStatsThird allCenter2WrampStatsOther allIntensityTableMain allIntensityTableThird allIntensityTableOther allSecondEdgeDistanceStatsMain allSecondEdgeDistanceStatsThird allSecondEdgeDistanceStatsOther allCenter2SecondStatsMain allCenter2SecondStatsThird allCenter2SecondStatsOther allColocStats masknames segnames baseDir imgDir imnamesByDir maskDir segDir percentile p mainChannel thirdChannel otherChannel
        for i = 1:numel(imgDir)
            if any(contains(imnamesByDir(i).imnames, imnames(imnum)))
                cd(imgDir(i))
            end
        end
        
        % Read in image using bioformats
        imgbf = bfopen(char(imnames(imnum)));
        imgcell = imgbf{1,1};
        for j = 1:size(imgcell, 1) %j = number of channels; 
            img(:,:,j) = im2double(imgcell{j,1});
            img16(:,:,j) = imgcell{j,1}; %NEW: uint16 version of image for saving 16-bit tiff.
        end
        
        % Set channel index using metadata
        if useMeta == 1
            mainChannel = metaTableAll{find(metaTableAll.Image == imnames(imnum)), mainChName};
            otherChannel = metaTableAll{find(metaTableAll.Image == imnames(imnum)), otherChName};
            thirdChannel = metaTableAll{find(metaTableAll.Image == imnames(imnum)), thirdChName};
        end
        
        if onlyOneChannel == 1
            otherChannel = 0; % Ensures that absent channels are assigned a value of zero
            thirdChannel = 0;
        elseif onlyTwoChannels == 1
            thirdChannel = 0;
        end
        
        % Change this if you want to use a different name to label the
        % channels in the saved figures instead of the file name suffix
        figNameMain = mainSuffix;
        figNameOther = otherSuffix;
        figNameThird = thirdSuffix;
        
        % Assign each channel's image to individual variables
        % NEW: save tiffs of each channel for CP because it can't read .nd2
        % files from new version of Nikon Elements
        imgMain = img(:,:,mainChannel);
        imwrite(img16(:,:,mainChannel), [baseDir, 'ImageTiffs\', char(extractBefore(imnames(imnum), '.nd2')), '_main.tif'], 'Compression', 'none')
        if otherChannel ~= 0
            imgOther = img(:,:,otherChannel);
            imwrite(img16(:,:,otherChannel), [baseDir, 'ImageTiffs\', char(extractBefore(imnames(imnum), '.nd2')), '_other.tif'], 'Compression', 'none')
        end
        if thirdChannel ~= 0
            imgThird = img(:,:,thirdChannel);
            imwrite(img16(:,:,thirdChannel), [baseDir, 'ImageTiffs\', char(extractBefore(imnames(imnum), '.nd2')), '_third.tif'], 'Compression', 'none')
        end
        
        % Background subtraction (subtracts median value of background mask from all 
        % pixels and sets pixels with negative values to zero)
         cd(maskDir) 
        [imgMainBg, maskMainBg, medBgMain] = bgSubtraction(imgMain, masknames, imnum);
        if otherChannel ~= 0
            [imgOtherBg, maskOtherBg, medBgOther] = bgSubtraction(imgOther, masknames, imnum);
        end
        if thirdChannel ~= 0
            [imgThirdBg, maskThirdBg, medBgThird] = bgSubtraction(imgThird, masknames, imnum);
        end
        
        if saveMaskBg == 1 % Save maskMainBg if running CellProfiler after this script
            imwrite(imcomplement(maskMainBg), [baseDir, '\BackgroundSubtraction\BgMask_', char(extractBefore(imnames(imnum), '.nd2')), '.tif'], 'Compression', 'none');
        end
        
        cd(segDir)
        segTemp = imread(segnames(imnum));

        % Calculate WRAMP parameters for each cell k in image
                
        % Regionprops stats for large image
        stats = regionprops(segTemp, 'PixelIdxList', 'Area', 'MajorAxisLength', 'MinorAxisLength', 'Orientation', 'PixelIdxList', 'MinFeretProperties', 'MaxFeretProperties', 'Eccentricity');
        originalId = 1:length(stats);
        for k = 1:length(stats)
            stats(k).OriginalId = originalId(k);
        end
        goodStats = stats(find([stats.MajorAxisLength] > 0));
        
        % Create tables for function outputs
        if otherChannel ~= 0
            colocStats = table('Size',[length(goodStats), 50], 'VariableTypes', repmat("double", 1, 50), 'VariableNames', {'percOverlapOther2Main', 'percOverlapThird2Main', 'percOverlapOther2Third', 'percOverlapMain2Other', 'percOverlapMain2Third', 'percOverlapThird2Other', 'percOverlapTriple', 'percOverlapBrightestThird2Main', 'percOverlapBrightestMain2Third', 'percOverlapBrightestOther2Main', 'percOverlapBrightestMain2Other', 'percOverlapBrightestOther2Third', 'percOverlapBrightestThird2Other', 'thirdAtWramp', 'otherAtWramp', 'otherAtWrampThird', 'pearsonThirdWramp', 'pearsonOtherWramp', 'pearsonOtherThirdWramp', 'mandersMainThirdBrightest1', 'mandersMainThirdBrightest2', 'mandersMainOtherBrightest1', 'mandersMainOtherBrightest2', 'mandersThirdOtherBrightest1', 'mandersThirdOtherBrightest2', 'pearsonThird', 'pearsonOther', 'pearsonOtherThird', 'mandersMainThird1', 'mandersMainThird2', 'mandersMainOther1', 'mandersMainOther2', 'mandersThirdOther1', 'mandersThirdOther2', 'pearsonThirdNotWramp', 'pearsonOtherNotWramp', 'thirdWrampOverNot', 'otherWrampOverNot', 'distCentrThird2Main', 'distCentrOther2Main', 'distCentrOther2Third', 'distWeightedThird2Main', 'distWeightedOther2Main', 'distWeightedOther2Third', 'sameSideCenterThird2Main', 'sameSideWeightedThird2Main', 'sameSideCenterOther2Main', 'sameSideWeightedOther2Main', 'sameSideCenterOther2Third', 'sameSideWeightedOther2Third'});
        end
        chStatsMain = table('Size', [length(goodStats), 22], 'VariableTypes', repmat("double", 1, 22), 'VariableNames', {'massDisplacement', 'wrampOrientation','angleWramp2Major','secondOrientation','angleSecond2Major','intensityWrampHalves', 'profileWrampScore', 'brightPixWrampHalf', 'intensityMajorHalves', 'profileMajorScore', 'brightPixMajorHalf', 'intensitySecondHalves', 'profileSecondScore', 'brightPixSecondHalf', 'angleWramp2Second', 'numCandidates', 'largeObj', 'brightMeanObj', 'brightSumObj', 'medianObjectMeanIntensity', 'medianObjectSumIntensity', 'medianObjectArea'});
        wrampEdgeDistanceStatsMain = table('Size',[length(goodStats), 10], 'VariableTypes', repmat("double", 1, 10), 'VariableNames', {'minDistCentrEdge', 'minDistWrampEdge', 'maxDistCentrEdge', 'maxDistWrampEdge', 'medianDistCentrEdge', 'medianDistWrampEdge', 'firstQuartileDistCentrEdge', 'firstQuartileDistWrampEdge', 'thirdQuartileDistCentrEdge', 'thirdQuartileDistWrampEdge'}); 
        secondEdgeDistanceStatsMain = table('Size',[length(goodStats), 10], 'VariableTypes', repmat("double", 1, 10), 'VariableNames', {'minDistCentrSecondEdge', 'minDistSecondEdge', 'maxDistCentrSecondEdge', 'maxDistSecondEdge', 'medianDistCentrSecondEdge', 'medianDistSecondEdge', 'firstQuartileDistCentrSecondEdge', 'firstQuartileDistSecondEdge', 'thirdQuartileDistCentrSecondEdge', 'thirdQuartileDistSecondEdge'});
        center2WrampStatsMain = table('Size',[length(goodStats), 7], 'VariableTypes', repmat("double", 1, 7), 'VariableNames', {'minDistCentr2Wramp', 'maxDistCentr2Wramp', 'medianDistCentr2Wramp', 'firstQuartileDistCentr2Wramp', 'thirdQuartileDistCentr2Wramp', 'distCentrs', 'wrampAngle'});
        center2SecondStatsMain = table('Size',[length(goodStats), 7], 'VariableTypes', repmat("double", 1, 7), 'VariableNames', {'minDistCentr2Second', 'maxDistCentr2Second', 'medianDistCentr2Second', 'firstQuartileDistCentr2Second', 'thirdQuartileDistCentr2Second', 'distCentrsSecond', 'secondAngle'});
        intensityTableMain = table('Size',[length(goodStats), 20], 'VariableTypes', repmat("double", 1, 20), 'VariableNames', {'meanIntensityCell', 'meanIntensityWramp', 'medianIntensityCell', 'medianIntensityWramp', 'sumIntensityCell', 'sumIntensityWramp', 'areaWramp', 'areaBrightObj', 'meanIntensityBrightObj', 'sumIntensityBrightObj', 'sumNotWramp', 'meanNotWramp', 'medianNotWramp', 'sumNotBright', 'meanNotBright', 'medianNotBright', 'meanIntensitySecond', 'sumIntensitySecond', 'medianIntensitySecond', 'areaSecond'});
        
        if onlyOneChannel == 0
            chStatsOther = table('Size', [length(goodStats), 22], 'VariableTypes', repmat("double", 1, 22), 'VariableNames', {'massDisplacement', 'wrampOrientation','angleWramp2Major','secondOrientation','angleSecond2Major','intensityWrampHalves', 'profileWrampScore', 'brightPixWrampHalf', 'intensityMajorHalves', 'profileMajorScore', 'brightPixMajorHalf', 'intensitySecondHalves', 'profileSecondScore', 'brightPixSecondHalf', 'angleWramp2Second', 'numCandidates', 'largeObj', 'brightMeanObj', 'brightSumObj', 'medianObjectMeanIntensity', 'medianObjectSumIntensity', 'medianObjectArea'});
            wrampEdgeDistanceStatsOther = table('Size',[length(goodStats), 10], 'VariableTypes', repmat("double", 1, 10), 'VariableNames', {'minDistCentrEdge', 'minDistWrampEdge', 'maxDistCentrEdge', 'maxDistWrampEdge', 'medianDistCentrEdge', 'medianDistWrampEdge', 'firstQuartileDistCentrEdge', 'firstQuartileDistWrampEdge', 'thirdQuartileDistCentrEdge', 'thirdQuartileDistWrampEdge'}); 
            secondEdgeDistanceStatsOther = table('Size',[length(goodStats), 10], 'VariableTypes', repmat("double", 1, 10), 'VariableNames', {'minDistCentrSecondEdge', 'minDistSecondEdge', 'maxDistCentrSecondEdge', 'maxDistSecondEdge', 'medianDistCentrSecondEdge', 'medianDistSecondEdge', 'firstQuartileDistCentrSecondEdge', 'firstQuartileDistSecondEdge', 'thirdQuartileDistCentrSecondEdge', 'thirdQuartileDistSecondEdge'});
            center2WrampStatsOther = table('Size',[length(goodStats), 7], 'VariableTypes', repmat("double", 1, 7), 'VariableNames', {'minDistCentr2Wramp', 'maxDistCentr2Wramp', 'medianDistCentr2Wramp', 'firstQuartileDistCentr2Wramp', 'thirdQuartileDistCentr2Wramp', 'distCentrs', 'wrampAngle'});
            center2SecondStatsOther = table('Size',[length(goodStats), 7], 'VariableTypes', repmat("double", 1, 7), 'VariableNames', {'minDistCentr2Second', 'maxDistCentr2Second', 'medianDistCentr2Second', 'firstQuartileDistCentr2Second', 'thirdQuartileDistCentr2Second', 'distCentrsSecond', 'secondAngle'});
            intensityTableOther = table('Size',[length(goodStats), 20], 'VariableTypes', repmat("double", 1, 20), 'VariableNames', {'meanIntensityCell', 'meanIntensityWramp', 'medianIntensityCell', 'medianIntensityWramp', 'sumIntensityCell', 'sumIntensityWramp', 'areaWramp', 'areaBrightObj', 'meanIntensityBrightObj', 'sumIntensityBrightObj', 'sumNotWramp', 'meanNotWramp', 'medianNotWramp', 'sumNotBright', 'meanNotBright', 'medianNotBright', 'meanIntensitySecond', 'sumIntensitySecond', 'medianIntensitySecond', 'areaSecond'});
        end
        if onlyTwoChannels == 0
            chStatsThird = table('Size', [length(goodStats), 22], 'VariableTypes', repmat("double", 1, 22), 'VariableNames', {'massDisplacement', 'wrampOrientation','angleWramp2Major','secondOrientation','angleSecond2Major','intensityWrampHalves', 'profileWrampScore', 'brightPixWrampHalf', 'intensityMajorHalves', 'profileMajorScore', 'brightPixMajorHalf', 'intensitySecondHalves', 'profileSecondScore', 'brightPixSecondHalf', 'angleWramp2Second', 'numCandidates', 'largeObj', 'brightMeanObj', 'brightSumObj', 'medianObjectMeanIntensity', 'medianObjectSumIntensity', 'medianObjectArea'});
            wrampEdgeDistanceStatsThird = table('Size',[length(goodStats), 10], 'VariableTypes', repmat("double", 1, 10), 'VariableNames', {'minDistCentrEdge', 'minDistWrampEdge', 'maxDistCentrEdge', 'maxDistWrampEdge', 'medianDistCentrEdge', 'medianDistWrampEdge', 'firstQuartileDistCentrEdge', 'firstQuartileDistWrampEdge', 'thirdQuartileDistCentrEdge', 'thirdQuartileDistWrampEdge'}); 
            secondEdgeDistanceStatsThird = table('Size',[length(goodStats), 10], 'VariableTypes', repmat("double", 1, 10), 'VariableNames', {'minDistCentrSecondEdge', 'minDistSecondEdge', 'maxDistCentrSecondEdge', 'maxDistSecondEdge', 'medianDistCentrSecondEdge', 'medianDistSecondEdge', 'firstQuartileDistCentrSecondEdge', 'firstQuartileDistSecondEdge', 'thirdQuartileDistCentrSecondEdge', 'thirdQuartileDistSecondEdge'});
            center2WrampStatsThird = table('Size',[length(goodStats), 7], 'VariableTypes', repmat("double", 1, 7), 'VariableNames', {'minDistCentr2Wramp', 'maxDistCentr2Wramp', 'medianDistCentr2Wramp', 'firstQuartileDistCentr2Wramp', 'thirdQuartileDistCentr2Wramp', 'distCentrs', 'wrampAngle'});
            center2SecondStatsThird = table('Size',[length(goodStats), 7], 'VariableTypes', repmat("double", 1, 7), 'VariableNames', {'minDistCentr2Second', 'maxDistCentr2Second', 'medianDistCentr2Second', 'firstQuartileDistCentr2Second', 'thirdQuartileDistCentr2Second', 'distCentrsSecond', 'secondAngle'});
            intensityTableThird = table('Size',[length(goodStats), 20], 'VariableTypes', repmat("double", 1, 20), 'VariableNames', {'meanIntensityCell', 'meanIntensityWramp', 'medianIntensityCell', 'medianIntensityWramp', 'sumIntensityCell', 'sumIntensityWramp', 'areaWramp', 'areaBrightObj', 'meanIntensityBrightObj', 'sumIntensityBrightObj', 'sumNotWramp', 'meanNotWramp', 'medianNotWramp', 'sumNotBright', 'meanNotBright', 'medianNotBright', 'meanIntensitySecond', 'sumIntensitySecond', 'medianIntensitySecond', 'areaSecond'});
        end
        % Use to remove bad/unprocessable segmented objects from analysis
        if imnum == 0
            skip = 0;  % Index (k) for unprocessable segmented object. Sometimes very oddly shaped masks or very bright rounded cells will cause errors in some of the functions. 
            % Most of these cells will be skipped automatically, but if
            % the code errors out on a loop, it can be excluded here.
        elseif imnum == 0
            skip = 0;
        else
            skip = 0;
        end
        for k = 1:length(goodStats)
            if k ~= skip
                close all
                clearvars -except k useMeta onlyOneChannel onlyTwoChannels saveMaskBg mainSuffix otherSuffix thirdSuffix metaTableAll dateRan otherChName mainChName thirdChName figNameMain figNameOther figNameThird imgMain imgThird imgOther imgInfo imnames seg segInfo allStats allChStatsMain allChStatsThird allChStatsOther imnum medBgMain medBgThird medBgOther segTemp goodStats chStatsMain chStatsThird chStatsOther colocStats imgMainBg imgThirdBg imgOtherBg maskMainBg wrampEdgeDistanceStatsMain wrampEdgeDistanceStatsThird wrampEdgeDistanceStatsOther center2WrampStatsMain center2WrampStatsThird center2WrampStatsOther intensityTableMain intensityTableThird intensityTableOther secondEdgeDistanceStatsMain secondEdgeDistanceStatsThird secondEdgeDistanceStatsOther center2SecondStatsMain center2SecondStatsThird center2SecondStatsOther allWrampEdgeDistanceStatsMain allWrampEdgeDistanceStatsThird allWrampEdgeDistanceStatsOther allCenter2WrampStatsMain allCenter2WrampStatsThird allCenter2WrampStatsOther allIntensityTableMain allIntensityTableThird allIntensityTableOther allSecondEdgeDistanceStatsMain allSecondEdgeDistanceStatsThird allSecondEdgeDistanceStatsOther allCenter2SecondStatsMain allCenter2SecondStatsThird allCenter2SecondStatsOther allColocStats skip masknames segnames baseDir imgDir imnamesByDir imnames1 imnames2 imnames3 imnames4 maskDir segDir percentile p mainChannel thirdChannel otherChannel
       
                goodStats(k).image = imnames(imnum);
                goodStats(k).cell = [char(extractBefore(imnames(imnum), '.nd2')), 'Cell_', num2str(goodStats(k).OriginalId)];
                goodStats(k).medBgMain = medBgMain;
                if otherChannel == 0
                    goodStats(k).medBgOther = NaN;
                else
                    goodStats(k).medBgOther = medBgOther;
                end
                if thirdChannel == 0
                    goodStats(k).medBgThird = NaN;
                else
                    goodStats(k).medBgThird = medBgThird;
                end

                % Extract mask of cell from segmentation
                [topRow, bottomRow, leftCol, rightCol] = cellCoordinates(imgMainBg, goodStats(k).PixelIdxList);
                maskCell = segTemp(topRow:bottomRow, leftCol:rightCol);
                objNum = unique(segTemp(goodStats(k).PixelIdxList));
                maskCell(maskCell ~= objNum) = 0; % Get rid of any other objects that might be contained in cropped portion of large image
                maskCell = imbinarize(maskCell);
                
                % Extract image of individual cell 
                imgCellMain = imgMain(topRow:bottomRow, leftCol:rightCol);
                cellMainAdjust = imadjust(imgCellMain, [min(imgCellMain(maskCell == 1)) max(imgCellMain(maskCell == 1))]); % Used only for visualization
                cellBgMain = imgMainBg(topRow:bottomRow, leftCol:rightCol);
                if otherChannel ~= 0
                    imgCellOther = imgOther(topRow:bottomRow, leftCol:rightCol);
                    cellOtherAdjust = imadjust(imgCellOther, [min(imgCellOther(maskCell == 1)) max(imgCellOther(maskCell == 1))]); % Used only for visualization
                    cellBgOther = imgOtherBg(topRow:bottomRow, leftCol:rightCol);
                end
                if thirdChannel ~= 0
                    imgCellThird = imgThird(topRow:bottomRow, leftCol:rightCol);
                    cellThirdAdjust = imadjust(imgCellThird, [min(imgCellThird(maskCell == 1)) max(imgCellThird(maskCell == 1))]); % Used only for visualization
                    cellBgThird = imgThirdBg(topRow:bottomRow, leftCol:rightCol);
                end

                % Find centroid of cell or nearest point contained in the
                % cell mask
                centrCell = cellCenter(maskCell);

                % Find WRAMP (brightest) and second brightest object
                % ("brightest" means object with greatest integrated
                % intensity after applying percentile-based threshold to the cell)
                [maskPctlMain, maskCombinedMain, pctlMain] = cellPrctileNoClose(cellBgMain, maskCell, percentile(p));
                if otherChannel ~= 0
                    if sum(imbinarize((cellBgOther > prctile(cellBgOther(maskCell == 1), percentile(p))).*maskCell), 'all') == 0
                        continue % This will skip cells where the 80th percentile fails (usually because intensity of the pixels in the cell is too constant (e.g., saturated the detector)       
                    end
                    [maskPctlOther, maskCombinedOther, pctlOther] = cellPrctileNoClose(cellBgOther, maskCell, percentile(p));
                end
                if thirdChannel ~= 0
                    [maskPctlThird, maskCombinedThird, pctlThird] = cellPrctileNoClose(cellBgThird, maskCell, percentile(p));
                end
                
                % Metrics calculated for each channel:
                for ch = [thirdChannel otherChannel mainChannel]
                    if ch ~= 0
                        switch ch
                            case mainChannel
                                cellBg = cellBgMain;
                                maskCombined = maskCombinedMain;
                                maskPctlClose = maskPctlMain;
                            case thirdChannel
                                cellBg = cellBgThird;
                                maskCombined = maskCombinedThird;
                                maskPctlClose = maskPctlThird;
                            case otherChannel
                                cellBg = cellBgOther;
                                maskCombined = maskCombinedOther;
                                maskPctlClose = maskPctlOther;
                        end

                        % Find weighted centroid
                        cellStats = regionprops(maskCell, cellBg, 'WeightedCentroid');
                        weightedCentr(1,1) = round(cellStats.WeightedCentroid(1,1));
                        weightedCentr(1,2) = round(cellStats.WeightedCentroid(1,2));
                        chStats.massDisplacement = sqrt((weightedCentr(1,1)-centrCell(1,1))^2 + (weightedCentr(1,2)-centrCell(1,2))^2);

                        % WRAMP metrics
                        intensityTable = intensityMetrics(cellBg, maskCell, maskCombined, maskPctlClose);
                        [center2WrampStats, centrWramp] = distFromCentr(maskCombined, centrCell, "WRAMP");
                        [center2SecondStats, centrSecond] = distFromCentr(maskCombined, centrCell, "Second");

                        wrampEdgeDistanceStats = wrampDistances(maskCombined, center2WrampStats.wrampAngle, "WRAMP");
                        secondEdgeDistanceStats = wrampDistances(maskCombined, center2SecondStats.wrampAngle, "Second");

                        % Angle to major axis from x-axis, expressed so that it is on
                        % the same side as the WRAMP structure. Note: Orientation from
                        % regionprops has the range (-90,90)                   
                        if center2WrampStats.wrampAngle > 90 && center2WrampStats.wrampAngle < 270 % W.S. to the left of the vertical axis
                            majAngle = goodStats(k).Orientation + 180;
                        elseif goodStats(k).Orientation < 0
                            majAngle = goodStats(k).Orientation + 360;
                        else
                            majAngle = goodStats(k).Orientation;
                        end
                        if ch == mainChannel
                            goodStats(k).majAngle = majAngle;
                        end
                        
                        % Remove this because still produces some weird
                        % values and I give up
                        [chStats.wrampOrientation, chStats.angleWramp2Major] = orient(goodStats(k).Orientation, center2WrampStats.wrampAngle);
                        [chStats.secondOrientation, chStats.angleSecond2Major] = orient(goodStats(k).Orientation, center2SecondStats.wrampAngle);

                        % Rotate cell so that axis between cell centroid and WRAMP centroid
                        % lies along x-axis
                        [maskWrampRotated, centroidsWrampRotated, smoothWrampProfile, chStats.intensityWrampHalves, chStats.profileWrampScore, chStats.brightPixWrampHalf] = profile(cellBg, maskCell, maskPctlClose, centrCell, centrWramp, center2WrampStats.wrampAngle, "WRAMP");
                        % Smoothed profile for generating figure, where the
                        % profile is measured along the wramp axis of the
                        % main channel for all channels.
                        if ch == mainChannel
                            wrampProfileMain = normProfileValues(maskCell, cellBgMain, center2WrampStats.wrampAngle);
                            if otherChannel ~= 0
                                wrampProfileOther = normProfileValues(maskCell, cellBgOther, center2WrampStats.wrampAngle);
                            end
                            if thirdChannel ~= 0
                                wrampProfileThird = normProfileValues(maskCell, cellBgThird, center2WrampStats.wrampAngle);
                            end  
                        end

                        % Rotate cell so that major axis lies along x-axis
                        [maskMajorRotated, centroidsMajorRotated, smoothMajorProfile, chStats.intensityMajorHalves, chStats.profileMajorScore, chStats.brightPixMajorHalf] = profile(cellBg, maskCell, maskPctlClose, centrCell, centrWramp, majAngle, "Major");

                        % Rotate cell so that axis between cell centroid and second
                        % object centroid lies along x-axis
                        if any(maskCombined == 2, 'all')
                            [maskSecondRotated, centroidsSecondRotated, smoothSecondProfile, chStats.intensitySecondHalves, chStats.profileSecondScore, chStats.brightPixSecondHalf] = profile(cellBg, maskCell, maskPctlClose, centrCell, centrSecond, center2SecondStats.wrampAngle, "WRAMP");
                            chStats.angleWramp2Second = abs(center2WrampStats.wrampAngle - center2SecondStats.wrampAngle);
                            if chStats.angleWramp2Second > 180
                                chStats.angleWramp2Second = 360 - chStats.angleWramp2Second;
                            end
                        else
                            chStats.intensitySecondHalves = NaN;
                            chStats.profileSecondScore = NaN;
                            chStats.brightPixSecondHalf = NaN;
                            chStats.angleWramp2Second = NaN;
                        end

                        [chStats.numCandidates, chStats.largeObj, chStats.brightMeanObj, chStats.brightSumObj, chStats.medianObjectMeanIntensity, chStats.medianObjectSumIntensity, chStats.medianObjectArea, candidateStats] = candidateObjects(maskPctlClose, cellBg);
                        switch ch 
                            case mainChannel
                                candidateStatsMain = candidateStats;
                            case otherChannel
                                candidateStatsOther = candidateStats;
                            case thirdChannel
                                candidateStatsThird = candidateStats;
                        end
                        
                        % Colocalization metrics relative to MCAM channel
                        if ch == mainChannel && onlyOneChannel == 0
                            if thirdChannel == 0
                                colocStats(k,:) = colocBrightest3ch2(maskPctlMain, maskPctlOther, maskCombinedMain, maskCombinedOther, cellBgMain, cellBgOther, pctlMain, pctlOther, centrCell, center2WrampStats.wrampAngle);
                            else
                                colocStats(k,:) = colocBrightest3(maskPctlMain, maskPctlThird, maskPctlOther, maskCombinedMain, maskCombinedThird, maskCombinedOther, cellBgMain, cellBgThird, cellBgOther, pctlMain, pctlThird, pctlOther, centrCell, center2WrampStats.wrampAngle);
                            end
                        end

                        % Save figures
                        if ch == mainChannel
                            if otherChannel == 0
                                [f1, f2] = parametersFigure(centrCell, onlyOneChannel, thirdChannel, cellMainAdjust, cellBgMain, maskCombinedMain, maskPctlMain, pctlMain, wrampProfileMain, candidateStatsMain, figNameMain);
                            elseif thirdChannel == 0
                                [f1, f2] = parametersFigure(centrCell, onlyOneChannel, thirdChannel, cellMainAdjust, cellBgMain, maskCombinedMain, maskPctlMain, pctlMain, wrampProfileMain, candidateStatsMain, figNameMain, cellOtherAdjust, cellBgOther, maskCombinedOther, maskPctlOther, pctlOther, wrampProfileOther, candidateStatsOther, figNameOther);
                            else
                                [f1, f2] = parametersFigure(centrCell, onlyOneChannel, thirdChannel, cellMainAdjust, cellBgMain, maskCombinedMain, maskPctlMain, pctlMain, wrampProfileMain, candidateStatsMain, figNameMain, cellOtherAdjust, cellBgOther, maskCombinedOther, maskPctlOther, pctlOther, wrampProfileOther, candidateStatsOther, figNameOther, cellThirdAdjust, cellBgThird, maskCombinedThird, maskPctlThird, pctlThird, wrampProfileThird, candidateStatsThird, figNameThird);
                            end
                            exportgraphics(f1, [baseDir, '\WrampMetrics\Output\Figures\', char(extractBefore(imnames(imnum), '.nd2')), '_', num2str(goodStats(k).OriginalId), '_Img_Cell_', num2str(percentile(p)), 'thPctlNoClose.png'], 'Resolution', 400)
                            saveas(f2, [baseDir, '\WrampMetrics\Output\Figures\', char(extractBefore(imnames(imnum), '.nd2')), '_', num2str(goodStats(k).OriginalId), '_Figure_Cell_',  num2str(percentile(p)), 'thPctlNoClose.png'])
            
                        end
                    end
                    switch ch
                        case mainChannel
                            chStatsMain(k,:) = struct2table(chStats');
                            wrampEdgeDistanceStatsMain(k,:) = wrampEdgeDistanceStats;
                            center2WrampStatsMain(k,:) = center2WrampStats;
                            intensityTableMain(k,:) = intensityTable;
                            secondEdgeDistanceStatsMain(k,:) = secondEdgeDistanceStats;
                            center2SecondStatsMain(k,:) = center2SecondStats;    
                        case otherChannel
                            if onlyOneChannel == 0
                                if otherChannel == 0
                                    chStatsTemp = struct('massDisplacement', NaN, 'wrampOrientation', NaN, 'angleWramp2Major', NaN, 'secondOrientation', NaN, 'angleSecond2Major', NaN, 'intensityWrampHalves', NaN, 'profileWrampScore', NaN, 'brightPixWrampHalf', NaN, 'intensityMajorHalves', NaN, 'profileMajorScore', NaN, 'brightPixMajorHalf', NaN, 'intensitySecondHalves', NaN, 'profileSecondScore', NaN, 'brightPixSecondHalf', NaN, 'angleWramp2Second', NaN, 'numCandidates', NaN, 'largeObj', NaN, 'brightMeanObj', NaN, 'brightSumObj', NaN, 'medianObjectMeanIntensity', NaN, 'medianObjectSumIntensity', NaN, 'medianObjectArea', NaN);
                                    chStatsOther(k,:) = struct2table(chStatsTemp');
                                else
                                    chStatsOther(k,:) = struct2table(chStats');
                                end
                                if otherChannel ~= 0
                                    chStatsOther(k,:) = struct2table(chStats');
                                    wrampEdgeDistanceStatsOther(k,:) = wrampEdgeDistanceStats;
                                    center2WrampStatsOther(k,:) = center2WrampStats;
                                    intensityTableOther(k,:) = intensityTable;
                                    secondEdgeDistanceStatsOther(k,:) = secondEdgeDistanceStats;
                                    center2SecondStatsOther(k,:) = center2SecondStats;
                                end
                            end
                        case thirdChannel
                            if onlyTwoChannels == 0
                                if thirdChannel == 0
                                    chStatsTemp = struct('massDisplacement', NaN, 'wrampOrientation', NaN, 'angleWramp2Major', NaN, 'secondOrientation', NaN, 'angleSecond2Major', NaN, 'intensityWrampHalves', NaN, 'profileWrampScore', NaN, 'brightPixWrampHalf', NaN, 'intensityMajorHalves', NaN, 'profileMajorScore', NaN, 'brightPixMajorHalf', NaN, 'intensitySecondHalves', NaN, 'profileSecondScore', NaN, 'brightPixSecondHalf', NaN, 'angleWramp2Second', NaN, 'numCandidates', NaN, 'largeObj', NaN, 'brightMeanObj', NaN, 'brightSumObj', NaN, 'medianObjectMeanIntensity', NaN, 'medianObjectSumIntensity', NaN, 'medianObjectArea', NaN);
                                    chStatsThird(k,:) = struct2table(chStatsTemp');
                                else
                                    chStatsThird(k,:) = struct2table(chStats');
                                end
                                if thirdChannel ~= 0
                                    wrampEdgeDistanceStatsThird(k,:) = wrampEdgeDistanceStats;
                                    center2WrampStatsThird(k,:) = center2WrampStats;
                                    intensityTableThird(k,:) = intensityTable;
                                    secondEdgeDistanceStatsThird(k,:) = secondEdgeDistanceStats;
                                    center2SecondStatsThird(k,:) = center2SecondStats;
                                end
                            end
                    end
                end
            end
        end
        if imnum == 1
            allStats = goodStats;
            allColocStats = colocStats;

            allChStatsMain = chStatsMain;
            allWrampEdgeDistanceStatsMain = wrampEdgeDistanceStatsMain;
            allCenter2WrampStatsMain = center2WrampStatsMain;
            allIntensityTableMain = intensityTableMain;
            allSecondEdgeDistanceStatsMain = secondEdgeDistanceStatsMain;
            allCenter2SecondStatsMain = center2SecondStatsMain;
            
            if onlyOneChannel == 0
                allChStatsOther = chStatsOther;
                allWrampEdgeDistanceStatsOther = wrampEdgeDistanceStatsOther;
                allCenter2WrampStatsOther = center2WrampStatsOther;
                allIntensityTableOther = intensityTableOther;
                allSecondEdgeDistanceStatsOther = secondEdgeDistanceStatsOther;
                allCenter2SecondStatsOther = center2SecondStatsOther;
            end
            if onlyTwoChannels == 0
                allChStatsThird = chStatsThird;
                allWrampEdgeDistanceStatsThird = wrampEdgeDistanceStatsThird;
                allCenter2WrampStatsThird = center2WrampStatsThird;
                allIntensityTableThird = intensityTableThird;
                allSecondEdgeDistanceStatsThird = secondEdgeDistanceStatsThird;
                allCenter2SecondStatsThird = center2SecondStatsThird;
            end
        else
            allStats = vertcat(allStats, goodStats);
            allColocStats = vertcat(allColocStats, colocStats);

            allChStatsMain = vertcat(allChStatsMain, chStatsMain);
            allWrampEdgeDistanceStatsMain = vertcat(allWrampEdgeDistanceStatsMain, wrampEdgeDistanceStatsMain);
            allCenter2WrampStatsMain = vertcat(allCenter2WrampStatsMain, center2WrampStatsMain);
            allIntensityTableMain = vertcat(allIntensityTableMain, intensityTableMain);
            allSecondEdgeDistanceStatsMain = vertcat(allSecondEdgeDistanceStatsMain, secondEdgeDistanceStatsMain);
            allCenter2SecondStatsMain = vertcat(allCenter2SecondStatsMain, center2SecondStatsMain);
            
            if onlyOneChannel == 0
                allChStatsOther = vertcat(allChStatsOther, chStatsOther);
                allWrampEdgeDistanceStatsOther = vertcat(allWrampEdgeDistanceStatsOther, wrampEdgeDistanceStatsOther);
                allCenter2WrampStatsOther = vertcat(allCenter2WrampStatsOther, center2WrampStatsOther);
                allIntensityTableOther = vertcat(allIntensityTableOther, intensityTableOther);
                allSecondEdgeDistanceStatsOther = vertcat(allSecondEdgeDistanceStatsOther, secondEdgeDistanceStatsOther);
                allCenter2SecondStatsOther = vertcat(allCenter2SecondStatsOther, center2SecondStatsOther);
            end 
            
            if onlyTwoChannels == 0
                allChStatsThird = vertcat(allChStatsThird, chStatsThird);
                allWrampEdgeDistanceStatsThird = vertcat(allWrampEdgeDistanceStatsThird, wrampEdgeDistanceStatsThird);
                allCenter2WrampStatsThird = vertcat(allCenter2WrampStatsThird, center2WrampStatsThird);
                allIntensityTableThird = vertcat(allIntensityTableThird, intensityTableThird);
                allSecondEdgeDistanceStatsThird = vertcat(allSecondEdgeDistanceStatsThird, secondEdgeDistanceStatsThird);
                allCenter2SecondStatsThird = vertcat(allCenter2SecondStatsThird, center2SecondStatsThird);
            end
        end
    end
    
    parameterTableCell = [struct2table(allStats) allColocStats];
    parameterTableMain = [allChStatsMain allIntensityTableMain allWrampEdgeDistanceStatsMain allCenter2WrampStatsMain allSecondEdgeDistanceStatsMain allCenter2SecondStatsMain];
    
    writetable(removevars(parameterTableCell, {'PixelIdxList'}), [baseDir, '\WrampMetrics\Output\', num2str(percentile(p)), 'thPctlNoCloseStats_Cell_', dateRan, '.csv']);
    writetable(parameterTableMain, [baseDir, '\WrampMetrics\Output\', num2str(percentile(p)), 'thPctlNoCloseStats_', mainSuffix, '_', dateRan, '.csv']);
    if onlyTwoChannels == 0
        parameterTableThird = [allChStatsThird allIntensityTableThird allWrampEdgeDistanceStatsThird allCenter2WrampStatsThird allSecondEdgeDistanceStatsThird allCenter2SecondStatsThird];
        writetable(parameterTableThird, [baseDir, '\WrampMetrics\Output\', num2str(percentile(p)), 'thPctlNoCloseStats_', thirdSuffix, '_', dateRan, '.csv']);
    end
    if onlyOneChannel == 0
        parameterTableOther = [allChStatsOther allIntensityTableOther allWrampEdgeDistanceStatsOther allCenter2WrampStatsOther allSecondEdgeDistanceStatsOther allCenter2SecondStatsOther];
        writetable(parameterTableOther, [baseDir, '\WrampMetrics\Output\', num2str(percentile(p)), 'thPctlNoCloseStats_', otherSuffix, '_', dateRan, '.csv']);
    end
end
